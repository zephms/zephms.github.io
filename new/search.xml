<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java装箱拆箱</title>
      <link href="/new/2021/04/24/JAVA/java%E8%A3%85%E7%AE%B1%E6%8B%86%E7%AE%B1/"/>
      <url>/new/2021/04/24/JAVA/java%E8%A3%85%E7%AE%B1%E6%8B%86%E7%AE%B1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Java SE5开始提供自动装箱</p><p>简单来说就是这样:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="keyword">new</span> Integer(<span class="number">10</span>); <span class="comment">// 手动装箱</span></span><br><span class="line"></span><br><span class="line">Integer i = <span class="number">10</span>;  <span class="comment">// 自动装箱</span></span><br><span class="line"><span class="keyword">int</span> n = i;   <span class="comment">// 自动拆箱</span></span><br></pre></td></tr></table></figure><p>自动将基本数据类型转换成包装器类型,自动将包装器类型转换为基本数据类型.</p><p>比如下面这段代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Integer i = <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">int</span> n = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译的时候,可以看出,装箱的时候,调用的是Integer的valueOf(int)方法.</p><p>拆箱的时候自动调用Integer的intValue方法</p><p>举个栗子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">        Integer i1 = <span class="number">100</span>;</span><br><span class="line">        Integer i2 = <span class="number">100</span>;</span><br><span class="line">        Integer i3 = <span class="number">200</span>;</span><br><span class="line">        Integer i4 = <span class="number">200</span>;</span><br><span class="line">         </span><br><span class="line">        System.out.println(i1==i2);</span><br><span class="line">        System.out.println(i3==i4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为 true false</p><p>因为,  i1和i2指向的是同一个对象,而i3和i4指向的是不同的对象,此时翻翻源码</p><p>这是valueOf:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= -<span class="number">128</span> &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + <span class="number">128</span>];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是IntegerCache:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// high value may be configured by property</span></span><br><span class="line">            <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">            <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Use Long.decode here to avoid invoking methods that</span></span><br><span class="line">                <span class="comment">// require Integer&#x27;s autoboxing cache to be initialized</span></span><br><span class="line">                <span class="keyword">int</span> i = Long.decode(integerCacheHighPropValue).intValue();</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - -low);</span><br><span class="line">            &#125;</span><br><span class="line">            high = h;</span><br><span class="line"></span><br><span class="line">            cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> j = low;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">                cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux系统简介</title>
      <link href="/new/2021/04/24/LINUX/Linux%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/"/>
      <url>/new/2021/04/24/LINUX/Linux%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h4 id="linux-为何物"><a href="#linux-为何物" class="headerlink" title="linux 为何物"></a>linux 为何物</h4><p>Linux 就是一个操作系统，就像你多少已经了解的 Windows（xp，7，8）和 Mac OS 。至于操作系统是什么，就不用过多解释了，如果你学习过前面的入门课程，应该会有个基本概念了，这里简单介绍一下操作系统在整个计算机系统中的角色。</p><img src="1-1.png" alt="图1-1" style="zoom:80%;" /><p>我们的 Linux 主要是系统调用和内核那两层。当然直观地看，我们使用的操作系统还包含一些在其上运行的应用程序，比如文本编辑器、浏览器、电子邮件等。</p><h4 id="UNIX进化史"><a href="#UNIX进化史" class="headerlink" title="UNIX进化史"></a>UNIX进化史</h4><p><img src="1467262784463.png" alt="1"></p><h4 id="大致路径"><a href="#大致路径" class="headerlink" title="大致路径"></a>大致路径</h4><p><img src="1-8.png" alt="1"></p><h4 id="shell的一些快捷键"><a href="#shell的一些快捷键" class="headerlink" title="shell的一些快捷键"></a>shell的一些快捷键</h4><table><thead><tr><th>按键</th><th>作用</th></tr></thead><tbody><tr><td><code>Ctrl+d</code></td><td>键盘输入结束或退出终端</td></tr><tr><td><code>Ctrl+s</code></td><td>暂停当前程序，暂停后按下任意键恢复运行</td></tr><tr><td><code>Ctrl+z</code></td><td>将当前程序放到后台运行，恢复到前台为命令<code>fg</code></td></tr><tr><td><code>Ctrl+a</code></td><td>将光标移至输入行头，相当于<code>Home</code>键</td></tr><tr><td><code>Ctrl+e</code></td><td>将光标移至输入行末，相当于<code>End</code>键</td></tr><tr><td><code>Ctrl+k</code></td><td>删除从光标所在位置到行末</td></tr><tr><td><code>Alt+Backspace</code></td><td>向前删除一个单词</td></tr><tr><td><code>Shift+PgUp</code></td><td>将终端显示向上滚动</td></tr><tr><td><code>Shift+PgDn</code></td><td>将终端显示向下滚动</td></tr></tbody></table><h4 id="shell常用的通配符"><a href="#shell常用的通配符" class="headerlink" title="shell常用的通配符"></a>shell常用的通配符</h4><table><thead><tr><th>字符</th><th>含义</th></tr></thead><tbody><tr><td><code>*</code></td><td>匹配 0 或多个字符</td></tr><tr><td><code>?</code></td><td>匹配任意一个字符</td></tr><tr><td><code>[list]</code></td><td>匹配 list 中的任意单一字符</td></tr><tr><td><code>[^list]</code></td><td>匹配 除 list 中的任意单一字符以外的字符</td></tr><tr><td><code>[c1-c2]</code></td><td>匹配 c1-c2 中的任意单一字符 如：[0-9][a-z]</td></tr><tr><td><code>&#123;string1,string2,...&#125;</code></td><td>匹配 string1 或 string2 (或更多)其一字符串</td></tr><tr><td><code>&#123;c1..c2&#125;</code></td><td>匹配 c1-c2 中全部字符 如{1..10}</td></tr></tbody></table><h4 id="获得帮助-man手册"><a href="#获得帮助-man手册" class="headerlink" title="获得帮助(man手册)"></a>获得帮助(man手册)</h4><p>man <command> 查询指令对应的帮助</p><p>通常 man 手册中的内容很多，你可能不太容易找到你想要的结果，不过幸运的是你可以在 man 中使用搜索<code>/&lt;你要搜索的关键字&gt;</code>，查找完毕后你可以使用<code>n</code>键切换到下一个关键字所在处，<code>shift+n</code>为上一个关键字所在处。使用<code>Space</code>（空格键）翻页，<code>Enter</code>（回车键）向下滚动一行，或者使用<code>k</code>，<code>j</code>（vim 编辑器的移动键）进行向前向后滚动一行。按下<code>h</code>键为显示使用帮助（因为 man 使用 less 作为阅读器，实为<code>less</code>工具的帮助），按下<code>q</code>退出。</p><p>想要获得更详细的帮助，你还可以使用<code>info</code>命令，不过通常使用<code>man</code>就足够了。如果你知道某个命令的作用，只是想快速查看一些它的某个具体参数的作用，那么你可以使用<code>--help</code>参数，大部分命令都会带有这个参数</p><h4 id="字符画命令"><a href="#字符画命令" class="headerlink" title="字符画命令"></a>字符画命令</h4><p>安装 banner</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install sysvbanner</span><br></pre></td></tr></table></figure><p>使用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">banner acbs</span><br><span class="line">printerbanner -w 50 ACBS</span><br></pre></td></tr></table></figure><p>w是宽度的意思,在显示屏中显示比较小,必须加上宽度限制</p><p>其他的还有toilet figlet</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install toilet</span><br><span class="line">sudo apt-get install giglet</span><br></pre></td></tr></table></figure><h3 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">who am i</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者(完全相同)</span></span><br><span class="line">who mom likes</span><br></pre></td></tr></table></figure><img src="document-uid735639labid3timestamp1531731170296.png" alt="img" style="zoom:80%;" /><p>输出的第一列表示打开当前伪终端的用户的用户名（要查看当前登录用户的用户名，去掉空格直接使用 <code>whoami</code> 即可），第二列的 <code>pts/0</code> 中 <code>pts</code> 表示伪终端，所谓伪是相对于 <code>/dev/tty</code> 设备而言的，还记得上一节讲终端时的那七个使用 <code>[Ctrl]</code>+<code>[Alt]</code>+<code>[F1]～[F7]</code> 进行切换的 <code>/dev/tty</code> 设备么，这是“真终端”，伪终端就是当你在图形用户界面使用 <code>/dev/tty7</code> 时每打开一个终端就会产生一个伪终端，<code>pts/0</code> 后面那个数字就表示打开的伪终端序号，你可以尝试再打开一个终端，然后在里面输入 <code>who am i</code>，看第二列是不是就变成 <code>pts/1</code> 了，第三列则表示当前伪终端的启动时间。</p><p>还有一点需要注意的是，在某些环境中 <code>who am i</code> 和 <code>who mom likes</code> 命令不会输出任何内容，这是因为当前使用的 SHELL 不是登录时的 SHELL，没有用户与 who 的 stdin 相关联，因此不会输出任何内容。例如我在本地的 Ubuntu 系统上输入这个命令就不会有提示。</p><img src="uid871732-20200302-1583140204433" alt="图片描述" style="zoom:80%;" /><p>此时我们只需要打开一个登录 SHELL 的终端例如 Tmux，或者通过 ssh 登录到本机，再在新的终端里执行命令即可。</p><h4 id="who命令的其他参数"><a href="#who命令的其他参数" class="headerlink" title="who命令的其他参数"></a>who命令的其他参数</h4><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td><code>-a</code></td><td>打印能打印的全部</td></tr><tr><td><code>-d</code></td><td>打印死掉的进程</td></tr><tr><td><code>-m</code></td><td>同<code>am i</code>，<code>mom likes</code></td></tr><tr><td><code>-q</code></td><td>打印当前登录用户数及用户名</td></tr><tr><td><code>-u</code></td><td>打印当前登录用户登录信息</td></tr><tr><td><code>-r</code></td><td>打印运行等级</td></tr></tbody></table><h4 id="查看和切换用户"><a href="#查看和切换用户" class="headerlink" title="查看和切换用户"></a>查看和切换用户</h4><p>一般 /home下的每一个文件夹就是一个普通目录</p><p><code>su &lt;user&gt;</code> 可以切换到用户 user，执行时需要输入目标用户的密码，</p><p><code>sudo &lt;cmd&gt;</code> 可以以特权级别运行 cmd 命令，需要当前用户属于 sudo 组，且需要输入当前用户的密码。</p><p><code>su - &lt;user&gt;</code> 命令也是切换用户，但是同时用户的环境变量和工作目录也会跟着改变成目标用户所对应的。退出当前用户跟退出终端一样，可以使用 <code>exit</code> 命令或者使用快捷键 <code>Ctrl+D</code>。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo adduser lilei # 新建一个叫lilei的用户</span><br><span class="line">sudo passwd lilei # 设置对应账户的密码,也可以设置当前账户的密码</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VMware和Hyperv</title>
      <link href="/new/2021/04/24/vmware%E5%92%8CWindowssandbox%E4%B8%8D%E5%85%BC%E5%AE%B9/"/>
      <url>/new/2021/04/24/vmware%E5%92%8CWindowssandbox%E4%B8%8D%E5%85%BC%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="VMware-Workstation-雷电手机正常运行"><a href="#VMware-Workstation-雷电手机正常运行" class="headerlink" title="VMware Workstation/雷电手机正常运行"></a>VMware Workstation/雷电手机正常运行</h2><ol><li>禁用Hyper-V，PowerShell/CMD管理员运行：<code>bcdedit /set hypervisorlaunchtype off</code></li><li>重新启动计算机</li></ol><h2 id="Docker-Windows-SandBox-Hyperv正常运行"><a href="#Docker-Windows-SandBox-Hyperv正常运行" class="headerlink" title="Docker/Windows SandBox/Hyperv正常运行"></a>Docker/Windows SandBox/Hyperv正常运行</h2><ol><li>重新开启Hyper-V，PowerShell/CMD管理员运行：<code>bcdedit /set hypervisorlaunchtype auto</code></li><li>重新启动计算机</li></ol><p><a href="https://github.com/AI0TSec/Blog/issues/52">解决VMware Workstation/Virutalbox（安卓模拟器）与Windows Sandbox/Hyper-v/Docker/Device/Credential Guard不兼容问题 · Issue #52 · AI0TSec/Blog · GitHub</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django-3 视图view</title>
      <link href="/new/2021/04/24/DJANGO/Django-3%E8%A7%86%E5%9B%BEview/"/>
      <url>/new/2021/04/24/DJANGO/Django-3%E8%A7%86%E5%9B%BEview/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>编辑 <code>myApp/views.py</code> 文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># myApp/views.py</span></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">index</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponse(<span class="string">&quot;Hello, world!&quot;</span>)</span><br></pre></td></tr></table></figure><p>可以看出来，我们想要看到的就是在页面中输出 <code>Hello, world!</code>。</p><p>但仅编写视图函数，并不能在 Django 页面上显示出来。如果想要看到效果，我们需要使用 URL 来映射到它。</p><p>接下来需要思考一下，视图函数是有了，它映射到那个 URL 路径下呢？也就是说浏览器访问了哪个网址，才会调用这个视图函数处理？</p><p>需要编辑 <code>myProject/urls.py</code> 文件，修改为以下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># myProject/urls.py</span></span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> myApp <span class="keyword">import</span> views  <span class="comment"># 引入视图函数</span></span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;admin/&#x27;</span>, admin.site.urls),</span><br><span class="line">    path(<span class="string">&#x27;&#x27;</span>, views.index, name=<span class="string">&#x27;index&#x27;</span>), <span class="comment"># 新增路由映射</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>最外层的 myApp 目录也就是 <code>/home/project/myProject</code> 为项目的主目录，引入其它文件中的对象，可以使用绝对路径或相对路径。</p><p>urlpatterns 为路由映射到视图函数的控制列表，当服务器收到浏览器发送过来的请求时，首先到这里检查是否有对应的视图函数。如果是 <a href="https://www.abc.com/">https://www.abc.com</a> 就让 index 来处理，如果是 <a href="https://www.abc.com/admin/">https://www.abc.com/admin/</a> 就让 admin.site.urls 来处理。</p><p>这一步我们将应用 <code>myApp</code> 里视图函数与 URL 映射到了一起。保存后刷新欢迎页，会看到页面显示了hello world,说明视图函数生效了</p><h4 id="有关这个path函数"><a href="#有关这个path函数" class="headerlink" title="有关这个path函数"></a>有关这个path函数</h4><table><thead><tr><th>参数</th><th>意义</th><th>是否必须</th></tr></thead><tbody><tr><td>route</td><td>route 是一个匹配 URL 的准则（类似正则表达式）。当 Django 响应一个请求时，它会从 urlpatterns 的第一项开始，按顺序依次匹配列表中的项，直到找到匹配的项。</td><td>必须</td></tr><tr><td>view</td><td>当 Django 找到了一个匹配的准则，就会调用这个特定的视图函数，并传入一个 HttpRequest 对象作为第一个参数，被“捕获”的参数以关键字参数的形式传入。</td><td>必须</td></tr><tr><td>kwargs</td><td>任意个关键字参数可以作为一个字典传递给目标视图函数。</td><td>可选</td></tr><tr><td>name</td><td>为你的 URL 取名能使你在 Django 的任意地方唯一地引用它，尤其是在模板中。这个有用的特性允许你只改一个文件就能全局地修改某个 URL 模式。</td><td>可选</td></tr></tbody></table><p>在上面的代码中，<code>route</code> 为空意味着我们可以直接在桌面环境下用链接 <code>http://localhost:8000/myApp/</code> 访问该视图函数。</p>]]></content>
      
      
      
        <tags>
            
            <tag> django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django-6 增删改</title>
      <link href="/new/2021/04/24/DJANGO/Django-6%E4%BD%BF%E7%94%A8MTV%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9/"/>
      <url>/new/2021/04/24/DJANGO/Django-6%E4%BD%BF%E7%94%A8MTV%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h4 id="设计表单"><a href="#设计表单" class="headerlink" title="设计表单"></a>设计表单</h4><p>在 <code>myApp/templates/myApp/detail.html</code> 里，添加一个表单。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">name</span>=<span class="string">&quot;addBook&quot;</span>&gt;</span></span><br><span class="line">  &#123;% csrf_token %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>书名：<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;name&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>作者：<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;author&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>出版社：<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;pub_house&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;添加&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>简要说明：</p><ul><li>上面的模板是输入相应的书名、作者和出版社后，点击添加，将数据存储到数据库并刷新页面显示出来。</li><li>我们设置表单的 <code>action=&quot;/addBook/&quot;</code>，并设置 <code>method=&quot;post&quot;</code>。使用 <code>method=&quot;post&quot;</code>（与其相对的是 <code>method=&quot;get&quot;</code>）是非常重要的，因为这个提交表单的行为会改变服务器端的数据,无论何时，当你需要创建一个改变服务器端数据的表单时，请使用 <code>method=&quot;post&quot;</code>。这不是 Django 的特定技巧，这是优秀的网站开发技巧。</li><li>由于我们创建一个 POST 表单（它具有修改数据的作用），所以我们需要小心跨站点请求伪造。 但你不必太过担心，因为 Django 已经拥有一个用来防御它的非常容易使用的系统。 简而言之，所有针对内部 URL 的 POST 表单都应该使用 <code>&#123;% csrf_token %&#125;</code> 模板标签。</li></ul><h4 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h4><p>之前提到过,urlpattern的name是唯一标识符,所以,通过那么就可以确定使用谁了,</p><p>原文如下:</p><p>举例项目只有一个应用 myApp。在一个真实的 Django 项目中，可能会有五个，十个，二十个，甚至更多应用。Django 如何分辨重名的 URL 呢？</p><p>举个例子，myApp 应用有 detail 视图，可能另一个博客应用也有同名的视图。Django 如何知道 <code>action=&quot;&quot;</code> 标签到底对应哪一个应用的 URL 呢？</p><p>答案是：在根 URLconf 中添加命名空间。在 <code>myProject/urls.py</code> 文件中稍作修改，加上 <code>app_name</code> 设置命名空间：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> myApp <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">app_name = <span class="string">&#x27;myApp&#x27;</span> <span class="comment"># 添加这一行</span></span><br><span class="line">urlpatterns = [</span><br><span class="line">    <span class="comment"># path(&#x27;admin/&#x27;, admin.site.urls),</span></span><br><span class="line">    path(<span class="string">&#x27;&#x27;</span>, views.detail, name=<span class="string">&#x27;detail&#x27;</span>),</span><br><span class="line">    path(<span class="string">&#x27;addBook/&#x27;</span>, views.addBook, name=<span class="string">&#x27;addBook&#x27;</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>现在回到 <code>myApp/templates/myApp/detail.html</code> 更改 <code>action</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;/addBook/&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">name</span>=<span class="string">&quot;addBook&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="添加书籍"><a href="#添加书籍" class="headerlink" title="添加书籍"></a>添加书籍</h4><p>创建 <code>addBook</code> 函数来实现我们添加书籍的功能。</p><p>将下面的代码添加到 myApp/views.py：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># myApp/views.py</span></span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponseRedirect</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> reverse</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addBook</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">if</span> request.method == <span class="string">&#x27;POST&#x27;</span>:</span><br><span class="line">        temp_name = request.POST[<span class="string">&#x27;name&#x27;</span>]</span><br><span class="line">        temp_author = request.POST[<span class="string">&#x27;author&#x27;</span>]</span><br><span class="line">        temp_pub_house = request.POST[<span class="string">&#x27;pub_house&#x27;</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">from</span> django.utils <span class="keyword">import</span> timezone</span><br><span class="line">    temp_book = Book(name=temp_name, author=temp_author, pub_house=temp_pub_house, pub_date=timezone.now())</span><br><span class="line">    temp_book.save()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 重定向</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponseRedirect(reverse(<span class="string">&#x27;detail&#x27;</span>))</span><br></pre></td></tr></table></figure><p>在 myProject/urls.py 里添加 URL 地址映射：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># myProject/urls.py</span></span><br><span class="line">path(<span class="string">&#x27;addBook/&#x27;</span>, views.addBook, name=<span class="string">&#x27;addBook&#x27;</span>),</span><br></pre></td></tr></table></figure><p>简单说明：</p><ul><li><code>request.POST</code> 是一个类字典对象，可以通过关键字的名字获取提交的数据。 这个例子中，<code>request.POST[&#39;name&#39;]</code> 以字符串形式返回<code>name</code>的值。<code>request.POST</code> 的值永远是字符串。</li><li>在添加书籍之后，代码返回一个 <code>HttpResponseRedirect</code> 而不是常用的 <code>HttpResponse</code>，<code>HttpResponseRedirect</code> 只接收一个参数：用户将要被重定向的 URL。</li><li>你应该在每次处理 POST 数据时，都返回<code>HttpResponseRedirect</code>。这也不是 Django 的特定技巧，这是优秀的网站开发的实践。</li><li>在这个例子中，我们在 <code>HttpResponseRedirect</code> 的构造函数中使用 <code>reverse()</code> 函数。这个函数避免了我们在视图函数中硬编码 URL。它需要我们给出想要跳转的视图的名字和该视图所对应的 URL 模式中需要给该视图提供的参数。<code>reverse()</code> 调用后将返回这样一个字符串：<code>/detail/</code>。</li></ul><p>添加书籍功能完成，现在可以随意添加书籍。</p><p>打开 Web 服务访问链接就可以查看效果：</p><p>添加前：</p><p><img src="Django-6%E4%BD%BF%E7%94%A8MTV%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9/e022008dfb53bf45f6610c3a43340269-0" alt="6-2.2-1"></p><p>添加后：</p><p><img src="Django-6%E4%BD%BF%E7%94%A8MTV%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9/b3835dde02612da5b8e16513738698d1-0" alt="6-2.2-2"></p><p style="color:red">具体什么是硬编码我还得查查</p><h4 id="删除书籍"><a href="#删除书籍" class="headerlink" title="删除书籍"></a>删除书籍</h4><p>删除书籍功能实现起来也很简单。</p><p>首先，在 <code>myApp/detail.html</code> 中设计我们的模板。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% for book in book_list.all %&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; book.name &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; book.author &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; book.pub_house &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; book.pub_date &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;&#123;% url &#x27;delBook&#x27; book.id %&#125;&quot;</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="comment">&lt;!--只添加这一行--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看出，只需要在每个书籍后面添加一个删除的按钮。删除时也传递了需要删除的图书的 <code>id</code>。</p><p>接着，配置 url，只需在 <code>myProject/urls.py</code> 中添加这一行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># myProject/urls.py</span></span><br><span class="line">path(<span class="string">&#x27;delBook/&lt;int:book_id&gt;&#x27;</span>, views.deleteBook, name=<span class="string">&#x27;delBook&#x27;</span>),</span><br></pre></td></tr></table></figure><p>这里 <code>&lt;int:book_id&gt;</code> 是接收传递的参数 <code>book_id</code>。</p><p>最后设计视图函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># myApp/views.py</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">deleteBook</span>(<span class="params">request, book_id</span>):</span></span><br><span class="line">    bookID = book_id</span><br><span class="line">    Book.objects.<span class="built_in">filter</span>(<span class="built_in">id</span>=bookID).delete()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 重定向</span></span><br><span class="line">    <span class="keyword">return</span> HttpResponseRedirect(reverse(<span class="string">&#x27;detail&#x27;</span>))</span><br></pre></td></tr></table></figure><p>这个视图中，获取到 book 的 id，根据 id 来删除指定书籍。最后跟上面的添加书籍函数相同，使用重定位刷新页面。</p><p>打开 Web 服务访问链接查看效果：</p><p>删除后：</p><p><img src="Django-6%E4%BD%BF%E7%94%A8MTV%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%A2%9E%E5%88%A0%E6%94%B9/d94c026f9842b9abe278138947a3918a-0" alt="6-2.3-1"></p>]]></content>
      
      
      
        <tags>
            
            <tag> django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django-5 模板template</title>
      <link href="/new/2021/04/24/DJANGO/Django-5%E6%A8%A1%E6%9D%BFtemplate/"/>
      <url>/new/2021/04/24/DJANGO/Django-5%E6%A8%A1%E6%9D%BFtemplate/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h4 id="创建模板"><a href="#创建模板" class="headerlink" title="创建模板"></a>创建模板</h4><p>首先,在 myProject/myApp 目录里创建一个 templates 目录。Django 将会在这个目录里查找模板文件。</p><p>在 myProject/myProject/settings.py 文件中的 <code>TEMPLATES</code> 配置项描述了 Django 如何载入和渲染模板。默认的设置文件设置了 <code>DjangoTemplates</code> 后端，并设置 <code>APP_DIRS = True</code>。这一选项将会让 <code>DjangoTemplates</code> 在每个 <code>INSTALLED_APPS</code> 文件夹中寻找 templates 子目录。</p><p><img src="3c5979092ddf41dfd3fd06618caf30de-0" alt="pic"></p><p>新建模板文件 myApp/templates/myApp/detail.html，并向其中写入如下代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--myApp/templates/myApp/detail.html--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Book List<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>书名<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>作者<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>出版社<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>出版时间<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  &#123;% for book in book_list.all %&#125;</span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; book.name &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; book.author &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; book.pub_house &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>&#123;&#123; book.pub_date &#125;&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  &#123;% endfor %&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>模板统一使用点符号 <code>.</code> 来访问变量的属性。在示例 <code>&#123;&#123; book.name &#125;&#125;</code> 中，首先 Django 尝试对 book 对象使用字典查找（也就是使用 <code>obj.get(str)</code> 操作），如果失败了就尝试属性查找（也就是 <code>obj.str</code> 操作），结果是成功了。如果这一操作也失败的话，将会尝试列表查找（也就是 <code>obj[int]</code> 操作）。</p><p>在 <code>&#123;% for ... in ... %&#125;</code> 循环中发生的函数调用：<code>book_list.all</code> 被解释为 Python 代码 <code>book_list.objects.all()</code>，将会返回一个可迭代的 <code>Book</code> 对象，这一对象可以在 <code>&#123;% for ... in ... %&#125;</code> 标签内部使用。</p><h4 id="创建视图"><a href="#创建视图" class="headerlink" title="创建视图"></a>创建视图</h4><p>现在我们要创建视图来返回图书列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># myApp/views.py</span></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="keyword">from</span> django.http <span class="keyword">import</span> HttpResponse</span><br><span class="line"><span class="keyword">from</span> myApp.models <span class="keyword">import</span> Book</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">detail</span>(<span class="params">request</span>):</span></span><br><span class="line">    book_list = Book.objects.order_by(<span class="string">&#x27;pub_date&#x27;</span>)[:<span class="number">5</span>]</span><br><span class="line">    context = &#123;<span class="string">&#x27;book_list&#x27;</span>: book_list&#125;</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;myApp/detail.html&#x27;</span>, context)</span><br></pre></td></tr></table></figure><p>在此视图函数 <code>detail</code> 中，首先将数据库的 Book 列表按照 <code>pub_date</code> 时间来排序，存储到变量 <code>book_list</code> 中。</p><p>“载入模板，填充上下文，再返回由它生成的 HttpResponse 对象”是一个非常常用的操作流程。于是 Django 提供了一个快捷函数 <code>render()</code>。</p><p><code>render()</code> 函数把 <code>request</code> 对象作为它的第一个参数，模板作为第二个参数，字典作为它的可选的第三个参数。它返回给定模板呈现的给定文本的一个 <code>HttpResponse</code> 对象。</p><p>在这里，<code>context</code> 信息将会返回到模板 <code>myApp/detail.html</code>。</p><h4 id="绑定链接"><a href="#绑定链接" class="headerlink" title="绑定链接"></a>绑定链接</h4><p>将新视图添加进 myProject.urls 模块里：</p><p>不过这里把刚才自己添加的index删掉了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># myProject/urls.py</span></span><br><span class="line"><span class="keyword">from</span> django.contrib <span class="keyword">import</span> admin</span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> myApp <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    <span class="comment"># path(&#x27;admin/&#x27;, admin.site.urls),</span></span><br><span class="line">    path(<span class="string">&#x27;&#x27;</span>, views.detail, name=<span class="string">&#x27;detail&#x27;</span>),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 manage.py runserver 0:8080</span><br></pre></td></tr></table></figure><p>页面显示了书的列表,就说明成功了</p>]]></content>
      
      
      
        <tags>
            
            <tag> django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django-4 模型</title>
      <link href="/new/2021/04/24/DJANGO/Django-4%E6%A8%A1%E5%9E%8Bmodel/"/>
      <url>/new/2021/04/24/DJANGO/Django-4%E6%A8%A1%E5%9E%8Bmodel/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h4 id="配置数据库"><a href="#配置数据库" class="headerlink" title="配置数据库"></a>配置数据库</h4><p>Django 的项目设置都包含在了 <code>myProject/myProject/settings.py</code> 中。</p><p>对于数据库，配置文件使用了 <code>SQLite</code> 作为默认的数据库文件。对于只是初步尝试 Django 的我们来说，这十分方便，无需再去配置其他的东西。</p><p>在实际开发中，我们会用到其它更具扩展性的数据库。例如 <code>MySQL</code>、<code>Oracle</code> 等。</p><p>如果你选择使用这些数据库，你需要安装相应数据库的绑定，然后改变设置文件中的 <code>DATABASE default</code>。</p><p>这里使用 SQLite 数据库，想要使用其它数据库，可以参考 <a href="https://docs.djangoproject.com/zh-hans/2.0/ref/settings/#std:setting-DATABASES">Django 官方文档 DATABASE</a>。记得配置设置文件中的 <code>TIME_ZONE</code> 为自己所在地的时区，中国地区为 <code>Asia/Shanghai</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TIME_ZONE = <span class="string">&#x27;Asia/Shanghai&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="创建模型"><a href="#创建模型" class="headerlink" title="创建模型"></a>创建模型</h4><p>模型是真实数据的简明描述。它包含了存储的数据所必要的字段和行为。Django 遵循<strong>不要重复自己（DRY 原则）</strong>。它的目标是让你只需要定义数据模型，然后其它的东西你都不用关心，都会自动从模型生成。</p><p>实验前，先进入到项目主目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> myProject</span><br></pre></td></tr></table></figure><p>在我们创建的图书馆应用中，需要创建一个模型 <code>Book</code>。<code>Book</code> 模型包括四个字段：书名、作者、出版社、出版日期。</p><p>向 <code>myApp/models.py</code> 文件中写入如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># myApp/models.py</span></span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    author = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    pub_house = models.CharField(max_length=<span class="number">200</span>)</span><br><span class="line">    pub_date = models.DateTimeField(<span class="string">&#x27;date published&#x27;</span>)</span><br></pre></td></tr></table></figure><p>从代码可以看出，模型是 <code>django.db.models.Model</code> 类的子类。每个模型有一些类变量，它们都表示模型里的一个数据库字段。</p><p>每个字段都是 <code>Field</code> 类的实例。比如字符字段是 <code>CharField</code>，日期字段被表示为 <code>DateTImeField</code>。这将告诉 Django 每个字段要处理的数据类型。</p><p>定义某些 <code>Field</code> 类实例需要参数。如上面的 <code>max_length=100</code> 中的 <code>max_length</code>。这个参数的用处不止于用来定义数据结构，也用于验证数据。</p><h4 id="激活模型"><a href="#激活模型" class="headerlink" title="激活模型"></a>激活模型</h4><p>通过前面的代码，Django 可以：</p><ul><li>为这个应用创建数据库 schema（生成 CREATE TABLE 语句）。</li><li>创建可以与 Book 对象进行交互的 Python 数据库 API。</li></ul><p>为了实现上述功能，我们首先要将 myApp 应用安装到我们项目中。</p><p>因为 <code>MyappConfig</code> 类写在文件 <code>myApp/apps.py</code> 中，所以它的路径为 <code>myApp.apps.MyappConfig</code>。</p><p>在设置文件中添加路径：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># myProject/settings.py</span></span><br><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="string">&#x27;django.contrib.admin&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.auth&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.contenttypes&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.sessions&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.messages&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.staticfiles&#x27;</span>,</span><br><span class="line">    <span class="comment"># &#x27;myApp&#x27;, 这一注释掉，不注释掉会因重复而报错</span></span><br><span class="line">    <span class="string">&#x27;myApp.apps.MyappConfig&#x27;</span>,</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>现在你的 Django 项目会包含 myApp 应用。 运行下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py makemigrations myApp</span><br></pre></td></tr></table></figure><p>你会看到这样的输出：</p><p><img src="Django-4%E6%A8%A1%E5%9E%8Bmodel/8ba33eaa1179c0dc163dd6b97c508ba2-0" alt="pic"></p><p>通过运行 <code>makemigrations</code> 命令，Django 会检测你对模型文件的修改，并且把修改的部分储存为一次迁移。</p><p>让我们看看迁移命令会执行哪些 SQL 语句。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 manage.py sqlmigrate myApp 0001</span><br></pre></td></tr></table></figure><p>可以看到创建的 SQL 语句：</p><p><img src="Django-4%E6%A8%A1%E5%9E%8Bmodel/a17f7ee54436da43ac6ae129f81ea58a-0" alt="pic"></p><p>现在运行 migrate 命令，在数据库里创建新定义的模型的数据表：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py migrate</span><br></pre></td></tr></table></figure><p>看到如下画面，则表示成功！,这一步是写到了db文件中</p><p><img src="Django-4%E6%A8%A1%E5%9E%8Bmodel/32885d474af3e293ef996cd11e3daa33-0" alt="pic"></p><h4 id="使用api"><a href="#使用api" class="headerlink" title="使用api"></a>使用api</h4><p>这里可以通过命令行的形式,使用python类对象的方式进行编辑数据库</p><p>原文如下:</p><p>现在尝试一下 Django 为我们创建的各种 API：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python manage.py shell</span><br></pre></td></tr></table></figure><p>使用这个命令而不是简单的使用 “Python” 是因为 manage.py 会设置 <code>DJANGO_SETTINGS_MODULE</code> 环境变量，这个变量会让 Django 根据 <code>myProject/settings.py</code> 文件来设置 Python 包的导入路径。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">In [1]: from myApp.models import Book</span><br><span class="line">In [2]: Book.objects.all()   <span class="comment"># 获取 Book 所有对象</span></span><br><span class="line">Out[1]: &lt;QuerySet []&gt;</span><br><span class="line">In [3]: from django.utils import timezone</span><br><span class="line">In [4]: b = Book(name=<span class="string">&#x27;Business&#x27;</span>, author=<span class="string">&#x27;Tom&#x27;</span>, pub_house=<span class="string">&#x27;First Press&#x27;</span>, pub_date=timezone.now())    <span class="comment">#创建</span></span><br><span class="line">In [5]: b.save() <span class="comment">#保存</span></span><br><span class="line">In [6]: b.id</span><br><span class="line">Out[6]: 1</span><br><span class="line">In [7]: b.name</span><br><span class="line">Out[7]: <span class="string">&#x27;Business&#x27;</span></span><br><span class="line">In [8]: b.pub_date</span><br><span class="line">Out[8]: datetime.datetime(2020, 4, 27, 7, 37, 59, 123686, tzinfo=&lt;UTC&gt;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django-2 环境搭建</title>
      <link href="/new/2021/04/24/DJANGO/Django-2%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
      <url>/new/2021/04/24/DJANGO/Django-2%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h4 id="Linux安装django"><a href="#Linux安装django" class="headerlink" title="Linux安装django"></a>Linux安装django</h4><p>我们首先在终端命令行更新 pip3：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip3 install -U pip</span><br></pre></td></tr></table></figure><p>安装 Django2 的最终版本 2.2.9：(也可以是其他版本)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install django==2.2.9</span><br></pre></td></tr></table></figure><p>此外我们还要安装一些其它的基础工具包，先安装 ipython 和 mysqlclient 这两个，其它的在需要时再进行安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install libmysqlclient-dev</span><br><span class="line">pip install ipython mysqlclient</span><br></pre></td></tr></table></figure><h4 id="创建web项目"><a href="#创建web项目" class="headerlink" title="创建web项目"></a>创建web项目</h4><p>执行命令 <code>django-admin startproject</code> 初始化一个 Django 项目，后面的参数为项目名称，我们这里的项目名称定为 myProject。执行 <code>tree myProject</code> 命令查看项目的目录结构：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ django-admin startproject myProject</span><br><span class="line"></span><br><span class="line">tree myProject</span><br><span class="line">$ tree myProject                                   </span><br><span class="line">myProject</span><br><span class="line">├── manage.py</span><br><span class="line">└── myProject</span><br><span class="line">    ├── __init__.py</span><br><span class="line">    ├── settings.py</span><br><span class="line">    ├── urls.py</span><br><span class="line">    └── wsgi.py</span><br><span class="line">1 directory, 5 files</span><br></pre></td></tr></table></figure><p>对主目录下的文件和目录依次说明：</p><ul><li><code>manage.py</code> 项目的入口文件，在后面的实验中我们会大量使用它来执行一些命令用来创建应用、启动项目、控制数据表迁移等。</li><li><code>myProject</code> 主目录下的同名子目录，为项目的核心目录，它里面包含配置文件和管理应用的文件。</li><li><code>myProject/__init__.py</code> 每个子目录都会包含这样一个 <code>__init__.py</code> 文件，它是一个空文件，在需要的时候会引入目录下的对象。</li><li><code>myProject/settings.py</code> 配置文件，里面包含对数据库的设置项、CSRF Token 的设置项、模板的设置项等全部设置。</li><li><code>myProject/urls.py</code> 路由控制文件，处理客户端请求，分发到对应的视图函数去处理。</li><li><code>myProject/wsgi.py</code> 处理请求和响应，我们很少去动它。</li></ul><p>在终端执行 <code>cd myProject</code> 命令进入到项目的主目录，然后执行如下命令创建一个名为 myApp 的应用，注意实验环境里不可以创建名为 test 的应用，某些情况下它与 Python 模块冲突：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd myProject</span><br><span class="line">python manage.py startapp myApp</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> myProject</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> python3 manage.py startapp myApp</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> tree</span></span><br><span class="line">.</span><br><span class="line">├── manage.py</span><br><span class="line">├── myApp</span><br><span class="line">│   ├── admin.py</span><br><span class="line">│   ├── apps.py</span><br><span class="line">│   ├── __init__.py</span><br><span class="line">│   ├── migrations</span><br><span class="line">│   │   └── __init__.py</span><br><span class="line">│   ├── models.py</span><br><span class="line">│   ├── tests.py</span><br><span class="line">│   └── views.py</span><br><span class="line">└── myProject</span><br><span class="line">    ├── __init__.py</span><br><span class="line">    ├── __pycache__</span><br><span class="line">    │   ├── __init__.cpython-35.pyc</span><br><span class="line">    │   └── settings.cpython-35.pyc</span><br><span class="line">    ├── settings.py</span><br><span class="line">    ├── urls.py</span><br><span class="line">    └── wsgi.py</span><br><span class="line"></span><br><span class="line">4 directories, 14 files</span><br></pre></td></tr></table></figure><p>如上所示，创建了名为 myApp 的应用后，在项目的主目录下出现了名为 myApp 的目录，这就是应用目录。</p><p>应用中的文件说明如下：</p><ul><li><code>myApp/admin.py</code> 用于控制后台管理的文件，在后面的实验中会用到。</li><li><code>myApp/apps.py</code> 用于管理应用本身的文件，包括应用的名字如何命名，默认就是 myApp 。</li><li><code>myApp/__init__.py</code> 空文件，前面已经介绍过。</li><li><code>myApp/migrations</code> 这是用于记录数据库变更信息的目录，Django 中自带的数据库版本控制功能就体现在这个目录，在学习数据存储时会详细介绍。</li><li><code>myApp/models.py</code> 创建映射类的文件，熟悉 Flask 的同学一定不陌生。</li><li><code>myApp/tests.py</code> 编写测试代码的文件。</li><li><code>myApp/views.py</code> 创建视图函数的文件，视图函数用于处理客户端发来的请求。</li></ul><p>创建一个应用后,该应用并未与项目产生联系，需要在配置文件中添加此应用。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim myProject/settings.py</span><br></pre></td></tr></table></figure><p>修改 INSTALLED_APPS 项，添加我们创建的应用名称 myApp，如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS = [</span><br><span class="line">    <span class="string">&#x27;django.contrib.admin&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.auth&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.contenttypes&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.sessions&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.messages&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;django.contrib.staticfiles&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;myApp&#x27;</span>                                     (+)</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h4 id="启动项目"><a href="#启动项目" class="headerlink" title="启动项目"></a>启动项目</h4><p>新打开一个终端并输入命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> myProject</span><br><span class="line">python3 manage.py runserver 0:8080</span><br></pre></td></tr></table></figure><p>正常就可以启动项目了</p><p>另外 settings.py 可以设置这两条,时区和语言</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LANGUAGE_CODE = <span class="string">&#x27;zh-hans&#x27;</span></span><br><span class="line">TIME_ZONE = <span class="string">&#x27;Asia/Shanghai&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django-7 MTV模式</title>
      <link href="/new/2021/04/24/DJANGO/Django-7MTV%E6%A8%A1%E5%BC%8F/"/>
      <url>/new/2021/04/24/DJANGO/Django-7MTV%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h4 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h4><p>在说 MTV 模式之前，让我们来简单的说说著名的 MVC 模式。</p><p>MVC，是模型（Model）-视图（View）-控制器（Controller）的缩写。其具体定义如下：</p><ul><li>M：模型（Model），数据存取层，负责业务对象和数据库对象。</li><li>V：视图（View），与用户的交互，负责显示与怎样显示。</li><li>C：控制器（Controller），接受用户动作，调用模型，输出相应视图。</li></ul><p>三者以一种插件似的，松耦合的方式连接在一起。</p><p><img src="document-uid731737labid7122timestamp1530773332746.png" alt="7-2.1-1"></p><h4 id="MTV"><a href="#MTV" class="headerlink" title="MTV"></a>MTV</h4><p>Django 的 MTV 设计模式是借鉴和遵循 MVC 的。</p><p>MTV 具体定义如下：</p><ul><li>M：模型（Model）,负责业务对象和数据库的关系映射。</li><li>T：模板（Template）,负责如何把页面展示给用户。</li><li>V：视图（View）,负责业务逻辑，并在适当时候调用模型和模板。</li></ul><h4 id="URL-分发器"><a href="#URL-分发器" class="headerlink" title="URL 分发器"></a>URL 分发器</h4><p>URL 分发器的作用是将页面请求分发给不同的视图（View）处理，视图再调用相应的模型（Model）和模板（Template）。</p><p>Django Web 框架：</p><p><img src="document-uid731737labid7122timestamp1530773348131.png" alt="7-2.1-2"></p><p>一个误区是把 MVC 模式与 MTV 模式等价替换。其实这样是不对的。</p><p>在 MTV 模式中，MVC 中的 View 分成了视图 View（展现哪些数据）和模板 Template（如何展现）2 个部分，而控制器（Controller）这个要素由框架自己来实现了，我们需要做的就是把 URL 对应到视图 V 就可以了，通过这样的 URL 配置，系统将一个请求发送到一个合适的视图。</p>]]></content>
      
      
      
        <tags>
            
            <tag> django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Selenium-1 基础知识</title>
      <link href="/new/2021/04/24/SELENIUM/Selenium-1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/new/2021/04/24/SELENIUM/Selenium-1%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>1,安装库</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip3 install selenium</span><br></pre></td></tr></table></figure><p>2,安装geckodriver</p><img src="www.baidu.com/img/PCpad_012830ebaa7e4379ce9a9ed1b71f7507.png" alt="百度~"><p>3,新建py文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"></span><br><span class="line">driver = webdriver.Firefox() <span class="comment"># 适当修改</span></span><br><span class="line">driver.get(<span class="string">&quot;https://www.acbs.top&quot;</span>)</span><br></pre></td></tr></table></figure><p>如果打开了浏览器,并且进入了输入的网站,那么环境配置就算成功了</p><h3 id="基础浏览器操作"><a href="#基础浏览器操作" class="headerlink" title="基础浏览器操作"></a>基础浏览器操作</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">driver = webdriver.Firefox()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 浏览器进入百度网站</span></span><br><span class="line">driver.get(<span class="string">&quot;https://www.baidu.com&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置浏览器宽800，高400</span></span><br><span class="line">driver.set_window_size(<span class="number">800</span>, <span class="number">400</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待3秒</span></span><br><span class="line">sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 刷新页面</span></span><br><span class="line">driver.refresh()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等待3秒</span></span><br><span class="line">sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 最大化窗口</span></span><br><span class="line">driver.maximize_window()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 退出浏览器</span></span><br><span class="line">driver.quit()</span><br></pre></td></tr></table></figure><p>以上代码会在浏览器中执行：</p><ul><li>打开浏览器</li><li>进入百度网站</li><li>设置窗口大小为宽 800，高 400</li><li>等待 3 秒</li><li>刷新页面</li><li>最大化窗口</li><li>退出浏览器</li></ul><p>还有后退和前进页面 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 后退到上一个页面--百度网站</span><br><span class="line">driver.back()</span><br><span class="line"></span><br><span class="line"># 前进到下一个页面--实验楼网站</span><br><span class="line">driver.forward()</span><br></pre></td></tr></table></figure><h3 id="获取元素-并进行操作"><a href="#获取元素-并进行操作" class="headerlink" title="获取元素,并进行操作"></a>获取元素,并进行操作</h3><p>webdriver 提供了一系列的元素定位(获取)方法，常用的有以下几种:</p><ul><li>id</li><li>name</li><li>class name</li><li>tag name</li><li>link text</li><li>partial link text</li><li>xpath</li><li>css selector</li></ul><p>分别对应 python webdriver 中的方法为：</p><ul><li>find_element_by_id()</li><li>find_element_by_name()</li><li>find_element_by_class_name()</li><li>find_element_by_tag_name()</li><li>find_element_by_link_text()</li><li>find_element_by_partial_link_text()</li><li>find_element_by_xpath()</li><li>find_element_by_css_selector()</li></ul><p><em>下面是一些操作</em>:</p><h4 id="点击定位到的元素"><a href="#点击定位到的元素" class="headerlink" title="点击定位到的元素"></a>点击定位到的元素</h4><ul><li><code>click()</code></li></ul><blockquote><p>使用方法：一般为先进行元素的定位，如果该元素可以点击如：超链接、文本框、带有超链接的图片等，则该元素可以进行点击操作：<code>find_element_by_xxx().click()</code>。</p></blockquote><h4 id="清空文本框、向文本框输入内容"><a href="#清空文本框、向文本框输入内容" class="headerlink" title="清空文本框、向文本框输入内容"></a>清空文本框、向文本框输入内容</h4><ul><li>清空：<code>clear()</code></li><li>输入：<code>.send_keys(&quot;输入的内容&quot;)</code></li></ul><blockquote><p>使用方法：无论是清空还是输入操作，都是先进行元素即文本框的定位，然后调用对应的方法，即：清空<code>find_element_by_xx().clear()</code>，输入<code>find_element_by_xx().send_keys(&quot;输入的内容&quot;)</code></p></blockquote><h4 id="获取元素属性"><a href="#获取元素属性" class="headerlink" title="获取元素属性"></a>获取元素属性</h4><ul><li>文本信息：<code>.text</code></li></ul><blockquote><p>使用方法：定位到对应元素以后，直接调用方法：<code>find_element_by_xx().text</code>，注意：text 后面不要加括号</p></blockquote><ul><li>元素尺寸：<code>.size</code></li></ul><blockquote><p>使用方法：同上</p></blockquote><ul><li>其他属性：<code>.get_attribute(&quot;想获取的属性名&quot;)</code></li></ul><blockquote><p>使用方法：定位到对应元素以后，调用<code>.get_attribute(&quot;属性名&quot;)</code>方法，传值为想获取的属性名。注：查看元素的各个属性可通过 Chrome 自带的<code>开发者工具</code>，快捷键为<code>F12</code>，通过<code>元素查看器</code>定位到想查看的元素，然后在开发者工具中查看具体的属性名，如<code>class</code>、<code>type</code>、<code>id</code>等。</p></blockquote><p>这里我们使用<a href="http://bbs.51testing.com/forum.php">51Testing 软件测试论坛</a>作为演示网站，如果大家没有账号需要先去注册一个，下面的代码将会使用到账号信息，在终端使用命令<code>vim demo3.py</code>创建文件并写入代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">driver = webdriver.Firefox()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入51testing网站</span></span><br><span class="line">driver.get(<span class="string">&quot;http://bbs.51testing.com/forum.php&quot;</span>)</span><br><span class="line">sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用id定位账号输入框并输入账号</span></span><br><span class="line">driver.find_element_by_id(<span class="string">&quot;ls_username&quot;</span>).send_keys(<span class="string">&quot;您的用户名&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用id定位密码输入框并输入密码</span></span><br><span class="line">driver.find_element_by_id(<span class="string">&quot;ls_password&quot;</span>).send_keys(<span class="string">&quot;密码&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定位“登录”按钮并获取登录按钮的文本</span></span><br><span class="line">txt = driver.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;lsform&quot;]/div/div[1]/table/tbody/tr[2]/td[3]/button&#x27;</span>).text</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印获取的文本</span></span><br><span class="line">print(txt)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定位“登录”按钮并获取登录按钮的type属性值</span></span><br><span class="line"><span class="built_in">type</span> = driver.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;lsform&quot;]/div/div[1]/table/tbody/tr[2]/td[3]/button&#x27;</span>).get_attribute(<span class="string">&quot;type&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印type属性值</span></span><br><span class="line">print(<span class="built_in">type</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定位“登录”按钮并进行点击操作</span></span><br><span class="line">driver.find_element_by_xpath(<span class="string">&#x27;//*[@id=&quot;lsform&quot;]/div/div[1]/table/tbody/tr[2]/td[3]/button&#x27;</span>).click()</span><br></pre></td></tr></table></figure><p>在终端执行<code>python3 demo3.py</code>运行，结果显示如下：</p><p>页面显示：</p><p><img src="document-uid600404labid7463timestamp1542344866802.png" alt="此处输入图片的描述"></p><img src="document-uid600404labid7463timestamp1542344875747.png" alt="此处输入图片的描述" style="zoom:80%;" /><p>执行以上代码后会在 xfce 中输出如下信息：</p><img src="document-uid600404labid7463timestamp1542344885450.png" alt="此处输入图片的描述" style="zoom:80%;" /><h4 id="下拉页面"><a href="#下拉页面" class="headerlink" title="下拉页面"></a>下拉页面</h4><p>说明：下拉页面需要用 js 命令</p><ul><li>下拉指定高度</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">js = <span class="string">&#x27;document.documentElement.scrollTop=具体的下拉高度值;&#x27;</span></span><br><span class="line">driver.execute_script(js)</span><br></pre></td></tr></table></figure><blockquote><p>解释：<code>js = &#39;document.documentElement.scrollTop=具体的下拉高度值;&#39;</code>为 js 语句，意为下拉页面滚动条；<code>driver.execute_script(js)</code>为 python 代码，意为执行上面的 js 语句。</p></blockquote><ul><li>用目标元素做参考下拉页面</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">target_element = driver.find_element_by_xx()</span><br><span class="line"></span><br><span class="line">js = <span class="string">&#x27;arguments[0].scrollIntoView();&#x27;</span></span><br><span class="line"></span><br><span class="line">driver.execute_script(js,target_element)</span><br></pre></td></tr></table></figure><blockquote><p>解释：<code>target_element = driver.find_element_by_xx()</code>先对目标元素进行定位；<code>js = &#39;arguments[0].scrollIntoView();&#39;</code>js 下拉命令；<code>driver.execute_script(js, target_element)</code>python 代码，执行脚本，传两个参数，第一个是 js 命令，第二个是目标元素。</p></blockquote><p>在终端使用命令<code>vim demo4.py</code>创建文件并写入代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/python3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line">driver = webdriver.Firefox()</span><br><span class="line">driver.get(<span class="string">&quot;http://bbs.51testing.com/forum.php&quot;</span>)</span><br><span class="line">sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 页面下拉指定高度</span></span><br><span class="line">js = <span class="string">&#x27;document.documentElement.scrollTop=800;&#x27;</span></span><br><span class="line">driver.execute_script(js)</span><br></pre></td></tr></table></figure><p>在终端执行<code>python3 demo4.py</code>运行，页面在等待 3 秒后会出现下拉行为。</p><h4 id="页面中的aleart弹窗"><a href="#页面中的aleart弹窗" class="headerlink" title="页面中的aleart弹窗:"></a>页面中的aleart弹窗:</h4><p>如果页面有<code>alert</code>形式的提醒框，则用以下语句</p><ul><li>driver.switch_to.alert</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">alert = driver.switch_to.alert</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看alert中的文字</span></span><br><span class="line">print(alert.text)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 点击确定</span></span><br><span class="line">alert.accept()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 点击取消（如果有）</span></span><br><span class="line">alert.dismiss()</span><br></pre></td></tr></table></figure><h4 id="切换窗口"><a href="#切换窗口" class="headerlink" title="切换窗口"></a>切换窗口</h4><ul><li>.switch_to.window()</li></ul><blockquote><p>说明：很多时候我们点击按钮以后会新开页面，这时候要根据页面的<code>句柄</code>来切换窗口，获取所有页面句柄方法为<code>.window_handles</code>，而获取当前页面的句柄语法则为<code>.current_window_handle</code>，现在我们假设页面开了两个窗口，那么如何在两个窗口之间进行切换呢？很简单，就是用一个<code>for</code>循环即可，如果循环到的句柄与当前句柄不一致，那么就切换句柄：</p></blockquote><p>注: 所谓句柄,是一个数字的字符串,”15” “21”等等</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取窗口所有句柄</span></span><br><span class="line">all_handles = driver.window_handles</span><br><span class="line"><span class="comment"># 获取当前窗口句柄</span></span><br><span class="line">curr_window = driver.current_window_handle</span><br><span class="line"><span class="comment"># 遍历所有句柄</span></span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> all_handles:</span><br><span class="line">    <span class="comment"># 如果不是当前窗口句柄</span></span><br><span class="line">    <span class="keyword">if</span> k != curr_window:</span><br><span class="line">        <span class="comment"># 窗口句柄切换</span></span><br><span class="line">        driver.switch_to.window(k)</span><br></pre></td></tr></table></figure><h4 id="定位iframe"><a href="#定位iframe" class="headerlink" title="定位iframe"></a>定位iframe</h4><ul><li>.switch_to.frame():切换到 iframe</li><li>.switch_to.default_content(): 切换出 iframe</li></ul><blockquote><p>说明：iframe 经常在账号、密码输入框、发帖内容编辑框处出现，一般我们需要先通过开发人员工具确定该输入框是否是 iframe，如果是，则需要先定位 iframe。对 iframe 定位，一般需要先通过 xpath 定位到 iframe 的位置，然后通过<code>.switch_to.frame()</code>方法切换到 iframe 中，iframe 就像一个盒子，我们进入了盒子内部，进行预期的操作，然后需要跳出盒子才能继续对页面元素进行操作，所以执行完 iframe 内的操作后需要跳出 iframe 可以通过<code>.switch_to.default_content()</code>方法。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">iframe = driver.find_element_by_xpath()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到iframe</span></span><br><span class="line"></span><br><span class="line">driver.switch_to.frame(iframe)</span><br><span class="line"></span><br><span class="line">...页面操作代码...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 跳出iframe</span></span><br><span class="line"></span><br><span class="line">driver.switch_to.default_content()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> selenium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Selenium-3 自动化测试思路</title>
      <link href="/new/2021/04/24/SELENIUM/Selenium-3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%80%9D%E8%B7%AF/"/>
      <url>/new/2021/04/24/SELENIUM/Selenium-3%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%8B%E8%AF%95%E6%80%9D%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>  对于测试人员来说，完善的测试用例是避免漏测的关键。对任何模块测试前编写对应的测试用例可以提高测试点覆盖率、测试效率，也可以在出现漏测的情况时进行回查反思，避免接下来的工作中再次出现类似情况。</p><p>常用的测试方法包括：<code>等价类</code>、<code>边界值</code>、<code>正交排列</code>、<code>因果图</code>、<code>场景法</code>。</p><ul><li>等价类</li></ul><blockquote><ol><li>适用场合:有数据输入的地方,可以使用等价类划分,将大量的数据划分出若干范围,从每个范围中挑选代表数据进行测试,避免穷举,提高测试效率。</li></ol></blockquote><blockquote><ol><li>等价类方法划分：<code>有效等价类</code>，<code>无效等价类</code> <code>有效等价类</code>:输入有意义,合理的数据集合； <code>无效等价类</code>:输入无意义的,不合理的数据集合；</li><li>等价类划分法使用步骤:</li></ol></blockquote><ul><li><p>分析需求划分等价类(分为初步划分和细化);</p></li><li><p>将等价类填写到&lt;&lt;等价类表&gt;&gt;中;</p></li><li><p>从每个等价类中至少挑选一个代表数据,编写测试用例,执行测试。</p></li><li><p>边界值</p></li></ul><blockquote><ol><li>适用场合:常用于数据输入的地方,一般作为等价类划分的补充,和等价类划分一起使用。</li><li>使用步骤:找到有效数据和无效数据之间的分界点,对分界点及其两边的点进行测试。</li></ol></blockquote><blockquote><ul><li><strong>使用等价类+边界值测试的思路</strong>：</li></ul></blockquote><ul><li><p>1.先对有效数据进行测试- 1 个测试用例尽可能的将多个控件的有效数据组合起来测(优化)</p></li><li><p>2.再对无效数据进行测试- 无效数据需要单独测试(为了避免屏蔽现象)</p></li><li><p>3.最后对多个无效数据组合测试(适当强化)</p></li><li><p>因果图</p></li></ul><blockquote><ol><li>适用场合:界面中考虑控件的组合和限制关系的情况(组合数量较少)。</li><li>因果图中常用的 9 个图形符号:恒等,与,或,非;互斥(E),唯一(O),包含(I),要求(R),屏蔽(M);</li><li>使用步骤:</li></ol></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+ 找出所有的输入条件(因),和所有的输出结果(果);</span><br><span class="line">+ 找出输入条件的所有组合和限制;</span><br><span class="line">+ 每组输入条件组合对应的输出结果,画因果图,填判定表(画因果图可以省略);</span><br><span class="line">+ 编写测试用例,每一列对应一条测试用例。</span><br></pre></td></tr></table></figure><ul><li>场景法</li></ul><blockquote><ol><li>适用场合:当需要测试软件的业务流程(逻辑)时,适合用场景法,场景法是基于业务的方法,有测试人员模拟用户在使用软件的各种不同的情况;</li></ol></blockquote><blockquote><ol><li>场景法划分：<code>基本流</code>和<code>备选流</code> &gt; <code>基本流</code>：也叫有效流或正确流,模拟用户正确的操作的过程; <code>备选流</code>：也叫无效流或错误流,模拟用户错误的操作的情景;</li></ol></blockquote><blockquote><ol><li>场景法的使用步骤:</li></ol></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">+ 分析需求,整理业务流程(逻辑),列出场景;</span><br><span class="line">+ 根据列出场景填写场景表;</span><br><span class="line">+ 为每个场景编写适当的测试用例(不一定是1:1的)。</span><br></pre></td></tr></table></figure><ul><li>正交排列</li></ul><blockquote><ol><li>适用场合:对于参数配置类软件,以及兼容性测试时需要考虑各个控件之间的组合情况(组合较多),使用正交排列法选择较少的组合达到最佳的测试效果。</li></ol></blockquote><blockquote><ol><li>使用步骤:</li></ol></blockquote><ul><li>分析需求,列出参与组合的控件以及每个控件的取值;</li><li>选择合适的正交表(确定 m = 控件取值个数, k = 控件数);</li><li>完成控件,控件取值对应因子和状态的映射;</li><li>编写测试用例。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> selenium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Django-1 简介</title>
      <link href="/new/2021/04/24/DJANGO/Django-1%E7%AE%80%E4%BB%8B/"/>
      <url>/new/2021/04/24/DJANGO/Django-1%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>Django 是使用 Python 开发的开源 Web 开发框架。使用 Django，你能以最小的代价构建和维护高质量的 Web 应用。 本课程将带你迅速了解 Django，为快速开发网站打好基础。</p><h4 id="为什么使用-Django"><a href="#为什么使用-Django" class="headerlink" title="为什么使用 Django"></a>为什么使用 Django</h4><ul><li>Django 诞生于新闻网站的环境中，它所提供的特性非常适合开发内容类的网站（例如：博客，交流社区，图片分享站等等…）。因为 Django 是在快节奏的新闻编辑环境中开发的，它的设计目的是使常见的 Web 开发任务变得快速而简单。</li><li>Django 是开源的，不是商业项目或者科研项目，它集中力量解决 Web 开发中所遇到的一系列问题。因此，Django 每天都在现有的基础上进步，以适应不断更迭的开发需求。这样既节省了开发时间，也提高了后期维护的效率。</li></ul><h3 id="Django概览"><a href="#Django概览" class="headerlink" title="Django概览"></a>Django概览</h3><p>我们分 3 个 Python 文件（models.py，urls.py，views.py）和 HTML 模板文件（template.html）</p><h4 id="设计模型-Model"><a href="#设计模型-Model" class="headerlink" title="设计模型 Model"></a>设计模型 Model</h4><p>Django 无需数据库就可以使用，通过对象关系映射器（Object-relational mapping），仅使用 Python 代码就可以描述数据结构。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># myProject/myApp/models.py</span></span><br><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> models</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">book</span>(<span class="params">models.Model</span>):</span></span><br><span class="line">    name = models.CharField(max_length=<span class="number">100</span>)</span><br><span class="line">    pub_date = models.DateField()</span><br></pre></td></tr></table></figure><p><code>models.py</code> 文件主要用一个 Python 类来描述数据表。称为模型(model) 。 运用这个类，你可以通过简单的 Python 代码来创建、检索、更新、删除 数据库中的记录而无需写一条又一条的 SQL 语句。</p><p>在这里我们创建了一个 book 模型，并定义了 name 和 pub_date 属性。</p><h4 id="设计视图-Views"><a href="#设计视图-Views" class="headerlink" title="设计视图 Views"></a>设计视图 Views</h4><p>在模型被定义之后，我们便可以在视图中引用模型。通常，视图根据参数检索数据，加载一个模板，并使用检索到的数据呈现模板。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># myProject/myApp/views.py</span></span><br><span class="line"><span class="keyword">from</span> django.shortcuts <span class="keyword">import</span> render</span><br><span class="line"><span class="keyword">from</span> .models <span class="keyword">import</span> Person</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">book_archive</span>(<span class="params">request, year</span>):</span></span><br><span class="line">    book_list = Person.objects.<span class="built_in">filter</span>(birth_year = year)</span><br><span class="line">    context = &#123;<span class="string">&#x27;year&#x27;</span>: year, <span class="string">&#x27;book_list&#x27;</span>: book_list&#125;</span><br><span class="line">    <span class="keyword">return</span> render(request, <span class="string">&#x27;books/year_archive.html&#x27;</span>, context)</span><br></pre></td></tr></table></figure><p><code>views.py</code> 文件包含了页面的业务逻辑。<code>book_archive()</code> 函数叫做视图。这里还用到了 <code>year_archive.html</code> 模板。</p><h4 id="设计链接-Urls"><a href="#设计链接-Urls" class="headerlink" title="设计链接 Urls"></a>设计链接 Urls</h4><p>优雅简洁的 URL 解析式是衡量高品质网站的重要标准。Django 鼓励使用漂亮的 URL 设计。</p><p>使用这些优美的 URL，只需要建立 URL 和 Python 回调函数简单的映射关系。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># myProject/myProject/urls.py</span></span><br><span class="line"><span class="keyword">from</span> django.urls <span class="keyword">import</span> path</span><br><span class="line"><span class="keyword">from</span> . <span class="keyword">import</span> views</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    path(<span class="string">&#x27;books/&lt;int:year&gt;&#x27;</span>, views.year_archive),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p><code>urls.py</code> 指出了什么样的 URL 调用什么视图。 在这个例子中 <code>books/xxxxx</code> 将会调用 <code>year_archive()</code> 这个函数。也就是说，在进入这个链接时，会返回视图函数的结果。</p><h4 id="设计模板-Templates"><a href="#设计模板-Templates" class="headerlink" title="设计模板 Templates"></a>设计模板 Templates</h4><p>Django 拥有强大的模板功能，使用该模板能设计出强大的 Web 页面。</p><ul><li><code>/template/year_archive.html</code></li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% block title %&#125;Books for &#123;&#123; year &#125;&#125;&#123;% endblock %&#125; &#123;&#123;% block content %&#125;&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Articles for &#123;&#123;years&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&#123;% for book in book_list %&#125;</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;&#123; book.name &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>Published &#123;&#123; book.pub_date|date:&quot;F j, Y&quot; &#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">&#123;% endfor %&#125; &#123;% end block %&#125;</span><br></pre></td></tr></table></figure><p><code>year_archive.html</code> 是 html 模板。使用带基本逻辑声明的模板语言，如 <code>&#123;% for book in book_list %&#125;</code>，它试图将函数返回的结果显示在网页上。</p><p>Django 的这种结构我们称之为 MTV 模式：M 代表模型（Model），T 代表模板（Template），V 代表视图（View）。这三个分别代表了三种不同功能的 Web 应用，各司其职，又彼此合作。 大家一定听说过 MVC 模式（Mode-View-Controller），MTV 模式本质上与 MVC 相同，都是让各组件保持低耦合的关系。 关于 MTV 模式我们将在后面部分详细的讲解。</p><p>以上只是 Django 的功能性概述，后面我们将每个部分拆分开来逐一讲解。</p>]]></content>
      
      
      
        <tags>
            
            <tag> django </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Selenium-2 xpath</title>
      <link href="/new/2021/04/24/SELENIUM/Selenium-2xpath/"/>
      <url>/new/2021/04/24/SELENIUM/Selenium-2xpath/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>xpath 使用路径表达式在 XML 文档中进行导航。也就是说，当我们用 xpath 进行定位的时候，代码会根据你写的 xpath 一层一层的进行定位。xpath 就像是一个地图，指引代码找到它的目标元素。</p><h4 id="浏览器获得xpath"><a href="#浏览器获得xpath" class="headerlink" title="浏览器获得xpath"></a>浏览器获得xpath</h4><p>点击屏幕左下方的<code>所有应用程序&gt;互联网&gt;Firefox 网络浏览器</code>就可以打开 Firefox 浏览器，然后进入实验楼 (<a href="http://www.shiyanlou.com/">www.shiyanlou.com</a>) 网站。现在要对“路径”按钮进行定位：</p><img src="document-uid18510labid8069timestamp1540365219551.png" alt="此处输入图片的描述" style="zoom:80%;" /><p>点击键盘的 F12，这时浏览器会弹出开发者工具：</p><p><img src="document-uid18510labid8069timestamp1540365247532.png" alt="此处输入图片的描述"></p><p>最左侧的方框+小箭头叫做元素选择器。单击这个元素选择器以后，去页面点击想定位的元素——“路径”：</p><p><img src="document-uid18510labid8069timestamp1540365506028.png" alt="此处输入图片的描述"></p><p>此时定位到的标签，就是“路径”按钮对应的 HTML 标签了。然后将光标移动至该标签处，单击鼠标右键，选择复制，可以看到，这里可以选择复制 css 路径（即 css_selector)，也可以选择复制 XPath。</p><p><img src="document-uid18510labid8069timestamp1540365526863.png" alt="此处输入图片的描述"></p><p>这里我们选择 XPath，然后在文本编辑器里就可以粘贴复制的 XPath 了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;*[@id&#x3D;&quot;header-navbar-collapses&quot;]&#x2F;ul[1]&#x2F;li[3]&#x2F;a</span><br></pre></td></tr></table></figure><h4 id="XPath介绍"><a href="#XPath介绍" class="headerlink" title="XPath介绍"></a>XPath介绍</h4><table><thead><tr><th>表达式</th><th>描述</th></tr></thead><tbody><tr><td>/</td><td>从根节点选取</td></tr><tr><td>//</td><td>从匹配选择的当前节点选择文档中的节点，而不考虑它们的位置。</td></tr><tr><td>.</td><td>选取当前节点</td></tr><tr><td>..</td><td>选取当前节点的父节点</td></tr><tr><td>@</td><td>选取属性</td></tr><tr><td>*</td><td>匹配任何元素节点</td></tr></tbody></table><p>根据上面的表格，我们分析一下这个 xpath：<code>//*[@id=&quot;header-navbar-collapses&quot;]/ul[1]/li[3]/a</code></p><ul><li><code>//</code>即从当前选择的文档节点开始</li><li><code>*</code>匹配任何元素节点</li><li><code>[@id=&quot;header-navbar-collapses&quot;]</code>通过<code>id</code>属性确认当前文档开始的节点位置，即从<code>id</code>为<code>header-navbar-collapses</code>的位置开始</li><li><code>/</code>这个斜杠没有打头，所以这里意思是<code>下一级</code></li><li><code>ul[1]</code>这里方括号中的<code>1</code>表示第一个<code>ul</code>标签。注意：xpath 中的标签数从 1 开始</li><li><code>li[3]</code>表示第三个<code>li</code>标签</li></ul><p><img src="document-uid18510labid8069timestamp1540365583668.png" alt="此处输入图片的描述"></p><p>再举一个例子</p><p><img src="document-uid18510labid8069timestamp1540365604687.png" alt="此处输入图片的描述"></p><p>现在来看“登录”的 xpath：<code>//*[@id=&quot;header-navbar-collapses&quot;]/ul[2]/li[2]/a</code></p><p><img src="document-uid18510labid8069timestamp1540365620203.png" alt="此处输入图片的描述"></p><ul><li><code>//</code>即从当前选择的文档节点开始</li><li><code>*</code>匹配任何元素节点</li><li><code>[@id=&quot;header-navbar-collapses&quot;]</code>通过<code>id</code>属性确认当前文档开始的节点位置</li><li><code>/</code>斜杠没有用作开头，所以这里是<code>下一级</code>的意思</li><li><code>ul[2]</code>定位到上面<code>id</code>属性下一层的第二个<code>ul</code>标签</li><li><code>li[2]</code>定位到<code>ul</code>下一层的第二个<code>li</code>标签</li><li><code>a</code>定位到<code>li</code>标签下一层的<code>a</code>标签</li></ul><h4 id="手写XPath"><a href="#手写XPath" class="headerlink" title="手写XPath"></a>手写XPath</h4><p>有时候我们用复制来的 xpath 并不能定位到我们想要的元素，原因在于有一些网站的<code>id</code>元素属性也是变化的。这时候我们就只能自己来写 xpath 了。</p><h5 id="例子一"><a href="#例子一" class="headerlink" title="例子一"></a>例子一</h5><p><img src="document-uid18510labid8069timestamp1540366178381.png" alt="此处输入图片的描述"></p><p>我们来定位“实验楼”这个图片元素的 xpath，看到的 HTML 文档结构如下图：</p><p><img src="document-uid18510labid8069timestamp1540366196719.png" alt="此处输入图片的描述"></p><p>分析：</p><ul><li>目标元素是<code>img</code>标签</li><li>从<code>img</code>标签往上查找文档，看有没有唯一的属性值，如<code>id</code>。注意，<code>class</code>属性值一般不是唯一的，所以一般不用<code>class</code>属性作为定位元素</li><li>发现文档中直到文档顶部也没有属性唯一的元素，所以这里我们就从文档顶部即根节点开始</li><li><code>/</code>的意思即<code>从根节点选取</code></li><li>所以我们可以确定 xpath 开头是<code>/</code></li><li>第一层是<code>html</code>标签，所以 xpath 初步确定为<code>/html</code></li><li>第二层是<code>body</code>标签，xpath 确定为<code>/html/body</code></li><li>目标元素在<code>body</code>标签下第三个<code>div</code>中，所以 xpath 确定为<code>/html/body/div[3]</code></li><li>下一层只有一个<code>div</code>标签，这是可以省略后面的<code>[1]</code>，即<code>/html/body/div[3]/div</code></li><li>再下一层在第二个<code>div</code>中，所以 xpath 确定为<code>/html/body/div[3]/div/div[2]</code></li><li>依次类推，继续向下一层定位，即可确定 xpath 为<code>/html/body/div[3]/div/div[2]/div/nav/div[1]/a/img</code></li></ul><h5 id="例子二"><a href="#例子二" class="headerlink" title="例子二"></a>例子二</h5><p><img src="document-uid18510labid8069timestamp1540366244466.png" alt="此处输入图片的描述"></p><p>我们来定位搜索框的 xpath，看到的 HTML 文档结构如下图：</p><p><img src="document-uid18510labid8069timestamp1540366263561.png" alt="此处输入图片的描述"></p><p>分析：</p><ul><li>目标元素是<code>a</code>标签</li><li>从目标元素开始往上查找属性唯一的元素</li><li>发现有<code>id</code>属性，且该属性值固定不变，所以可以直接利用<code>id</code>属性进行定位</li><li><code>//</code>即从当前选择的文档节点开始，即<code>//*[@id=&#39;header-navbar-collapses&#39;]</code></li><li>下一层<code>ul</code>不唯一，所以 xpath 里要写索引，即<code>//*[@id=&quot;header-navbar-collapses&quot;]/ul[1]</code></li><li>接下来的<code>li</code>标签也不是唯一的，所以 xpath 确定为<code>//*[@id=&quot;header-navbar-collapses&quot;]/ul[1]/li[1]</code></li><li>最后定位到<code>a</code>标签，所以确定 xpath 为<code>//*[@id=&quot;header-navbar-collapses&quot;]/ul[1]/li[1]/a</code></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> selenium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 引用类型</title>
      <link href="/new/2021/03/02/CPP/cpp%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/"/>
      <url>/new/2021/03/02/CPP/cpp%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>$\alpha$<br>hhh</p><p>// 引用类型<br>// 引用类型是cpp中新增加的类型,用标识符&amp;来表示,<br>// 本质是对已经有的变量起的一个别名<br>// 一般形式: 数据类型 &amp; 引用变量名 = 已定义过的变量名<br>float x = 5;<br>float &amp; y1 = x; //针对一个变量,重新定义一个别名<br>cout&lt;&lt;y1&lt;&lt;endl;<br>// 引用类型可以用在函数传参上,使用引用进行接受参数<br>// 例如:<br>int max_a=3, max_b=8, max_res;<br>bs_max(max_a, max_b, max_res); // 传入的是int类型,使用引用类型进行接收.这样,函数内部的更改就是对int类型的更改<br>cout&lt;&lt;max_res&lt;&lt;endl;</p><p>// const类型<br>cout&lt;&lt;”============”&lt;&lt;endl;<br>// 关键字const可以用来限制 变量,函数参数,函数返回值 的修改<br>// const修饰一个变量的时候,则限定该变量在定义域范围内为常量,并要求该变量在初始化的时候进行赋值,以后不允许重新赋值或者修改<br>// c语言时,使用的是宏定义命令常量,即 #define, cpp后就用const定义常量<br>//      相对于宏定义,const可以用来进行类型检查,且可以像局部变量一样在程序的任意位置进行定义<br>const int Maxlen = 50;<br>// todo 此处应该补上关于 限制函数参数,函数返回值 的方法</p><p>// 函数<br>// 相对与c,cpp的函数有很多优点, 主要体现在 1,要求函数原型, 2,允许内联函数, 3,带缺省值的函数, 4,函数重载 ,…<br>int show1(); // 只要定义了函数原型,系统编译即可通过, 然后再程序后面补上函数体就可以,如果不补的话依旧运行不了,会报错undefined reference<br>show1();<br>// 内联函数:<br>// 在函数声明的时候加上inline字样,此时编译器会将 程序中出现的对该函数的调用 用该函数的函数体 来代替,用于提高运行效率<br>// 另外,内联函数中不允许使用 循环和开关 ,否则系统将其视为普通函数<br>// 内联函数的使用会增加代码量,但是会提高性能,也有说,用空间换取时间<br>// 网上还提到一点:类结构中所在的类说明内部定义的函数是内联函数。 具体等看看类再说啵<br>// todo 对应上一行<br>// 带缺省参数的函数:<br>// 函数的参数可以带有默认值,但是默认值的设置要遵守从右到左的顺序, 即 若某个参数有默认值,则后面必须都有默认值<br>defaultPara(5, 6); // 使用的时候从左到右填入,不可以跳着填,最后的可以省略<br>// 缺省参数的优点– 1方便函数调用语句的书写, 2,方便软件系统的扩张和改进,函数增加功能后,可以通过缺省参数的形式保证原有程序的正确运行<br>//          3, 方便类的构造函数设计</p><p>// 函数的重载:<br>// 建立多个函数名相同,但是参数列表不相同的函数.<br>// 函数返回类型可以相同,也可以不同,但是形参必须不同,这种不同可以是参数个数不同也可以是参数类型不同<br>// 函数的重载又称为函数的多态性.通过改变形参个数或类型使多个函数共用一个函数名</p><p>// 名字空间:<br>// 名字空间可以看作一个比程序模块更大的包,在名字空间中可以封装代码<br>// 使用方式– 1, 使用作用域运算符”::”, 2,使用using namespace xxx语句,将所有名字在该空间内可见<br>first_space::func();<br>second_space::func();</p><p>// cpp内存动态分配:<br>// cpp新增 new和delete运算符,用于动态存储空间的分配和释放<br>// 所谓动态存储空间,是指系统提供的一个叫做堆的内存区域,需要用的时候,使用new申请,不使用的时候使用delete释放内存空间给系统<br>// new一般形式: new 类型名 (初始值) | new 类型名 [数组个数]<br>// 申请单个变量时,可以有初始值,申请数组的时候不能有初始值,只接受数组个数<br>// 当动态空间申请不成功的时候new会返回空指针NULL<br>// delete一般格式: delete 指针 (释放指针的空间) | delete[] 指针 (释放动态数组的空间)<br>char* string1, s1[]=”Data Structure”;<br>int length = 14;<br>string1 = new char[length];<br>for(int i=0;i&lt;length;i++){<br>string1[i] = s1[i];<br>}<br>cout&lt;&lt;string1&lt;&lt;endl;<br>cout&lt;&lt;s1&lt;&lt;endl;</p><pre><code>return 0;</code></pre><p>}</p><p>int show1(){<br>    cout&lt;&lt;”show1 function”&lt;&lt;endl;<br>}</p>]]></content>
      
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 标准IO</title>
      <link href="/new/2021/03/01/CPP/cpp%E6%A0%87%E5%87%86io/"/>
      <url>/new/2021/03/01/CPP/cpp%E6%A0%87%E5%87%86io/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="cpp-标准IO"><a href="#cpp-标准IO" class="headerlink" title="cpp 标准IO"></a>cpp 标准IO</h3><p>cpp兼容了C语言的IO系统,并且独创了面向对象式的系统</p><p>流的概念:将输入输出看作一个流,不需要考虑具体设备的细节</p><h5 id="书写格式"><a href="#书写格式" class="headerlink" title="书写格式:"></a>书写格式:</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cin</span>&gt;&gt;内容&gt;&gt;内容&gt;&gt;...;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;内容&lt;&lt;内容&lt;&lt;...;</span><br></pre></td></tr></table></figure><p>cin: 是istream中的对象, 用来进行标准输入</p><p>cout: 是ostream中的对象, 用来进行标准输出</p><h5 id="设置IO格式"><a href="#设置IO格式" class="headerlink" title="设置IO格式:"></a>设置IO格式:</h5><ul><li>设置IO格式时 cpp预定义的算子:</li></ul><p>dec hex oct : 十进制, 十六进制, 八进制<br>ws : 输入跳过开始的空格<br>endl : 换行并刷新输出流<br>ends : 插入空字符结束字符串<br>setw(int w) : 设置输出宽度<br>flush : 刷新输出流(从缓存区实际输出)<br>setbase : 转换基数设置<br>setiosflags(long f) : 设置格式标志<br>resetiosflags(long f) : 解除设置格式标志<br>setfill(int c) : 填充字符<br>setprecision(int p) : 设置填充精度</p><ul><li>注意</li></ul><p>1, 定义即生效,对整个流都有效果<br>2, setwn对于更长的字符串没有效果,但是如果是较短的字符串会自动在左侧进行补齐 (此命令只起作用1次)<br>3, setiostream(ios::left)和setiosflags(ios::right)用来控制屏幕输出字符左对齐还是右对齐, 默认是右对齐<br>4, serfill设置填充字符,默认是空格</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span>&lt;&lt;setfill(<span class="string">&#x27;h&#x27;</span>)&lt;&lt;setw(<span class="number">7</span>)&lt;&lt;<span class="number">1234</span>&lt;&lt;<span class="built_in">endl</span>; 更换默认的填充字符</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;setiosflags(ios::left)&lt;&lt;setw(<span class="number">7</span>)&lt;&lt;<span class="number">1234</span>&lt;&lt;<span class="built_in">endl</span>; 更换默认的对齐方式</span><br></pre></td></tr></table></figure><p>5, 一个流只有处于无错状态,我们才能对其进行读写,确定一个流对象的状态的最简单的方法是将其作为一个条件来使用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">while(cin&gt;&gt;word)</span><br></pre></td></tr></table></figure><h5 id="高级的IO"><a href="#高级的IO" class="headerlink" title="高级的IO"></a>高级的IO</h5><ul><li>三个头文件</li></ul><table><thead><tr><th>Header</th><th align="left">Type</th><th></th></tr></thead><tbody><tr><td>iostream</td><td align="left">istream 从流中读取<br />ostream 写到流中去<br />iostream 对流进行读写,从  istream 和 ostream 派生而来</td><td>定义读写控制窗口的类型</td></tr><tr><td>fstream</td><td align="left">ifstream 从文件中读取, 由  istream 派生而来<br />ofstream 写到文件中去, 由  ostream 派生而来<br />fstream 读写文件, 由  iostream 派生而来</td><td>定义读写已命名文件的类型</td></tr><tr><td>sstream</td><td align="left">istringstream 从  string 对象中读取, 由 istream 派生而来<br />ostringstream 写到  string 对象中去, 由 ostream 派生而来<br />stringstream 对 string  对象进行读写, 由 iostream 派生而来</td><td>定义用于读写存储在内存中的 string 对象</td></tr></tbody></table><ul><li>缓冲区</li></ul><p>非系统的IO都会认为增加缓冲区来提高IO效率,cpp标准IO也不例外,以下是触发缓冲区刷新的方式</p><ol><li>程序正常结束,作为main函数return的一部分.</li><li>缓冲区满时,要刷新缓冲,新的数据才能写入.</li><li>可以使用操纵符如endl来显式刷新缓冲区.</li><li>在每个输出操作之后,我们可以用操纵符unitbuf设置流的内部状态,来清空缓冲区.默认情况下,对cerr就是设置unitbuf的.</li><li>一个输出流可能会被关联到另一个流,这种情况下,当读写被关联的流时,关联到流的缓冲区会被刷新.例如,默认情况下,cin和cerr都关联到cout,所以,读cin或者写cerr都会导致cout的缓冲区被刷新.</li></ol><p>刷新输出缓冲区:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;hi&quot;</span>&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//输出hi和一个换行,然后刷新缓冲区</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;hi&quot;</span>&lt;&lt;flush; <span class="comment">//输出hi,然后刷新缓冲区</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;hi&quot;</span>&lt;&lt;ends; <span class="comment">//输出hi和一个空字符,然后刷新缓冲区</span></span><br></pre></td></tr></table></figure><p>unitbuf设置方法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cout&lt;&lt;unitbuf; &#x2F;&#x2F;所有输出操作后都会立刻刷新缓冲区</span><br><span class="line">cout&lt;&lt;nounitbuf; &#x2F;&#x2F;回到正常的缓冲方式</span><br></pre></td></tr></table></figure><p>注意 程序崩溃的时候,会有数据停留在缓冲区中没出来,可以考虑确认刷新.</p><p>… 还有好多</p><p><a href="https://www.jianshu.com/p/1c83da435755">https://www.jianshu.com/p/1c83da435755</a></p><p><a href="https://www.cnblogs.com/1zhk/p/5014442.html">https://www.cnblogs.com/1zhk/p/5014442.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 数据类型</title>
      <link href="/new/2021/03/01/CPP/cpp%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/new/2021/03/01/CPP/cpp%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型:"></a>数据类型:</h3><p>使用编程语言进行编程时，需要用到各种变量来存储各种信息。变量保留的是它所存储的值的内存位置。这意味着，当创建一个变量时，就会在内存中保留一些空间。可能需要存储各种数据类型（比如字符型、宽字符型、整型、浮点型、双浮点型、布尔型等）的信息，操作系统会根据变量的数据类型，来分配内存和决定在保留内存中存储什么。</p><p>相对于C语言,cpp在枚举类型和结构体类型上有所提高</p><h4 id="7种内置的基本数据类型"><a href="#7种内置的基本数据类型" class="headerlink" title="7种内置的基本数据类型"></a>7种内置的基本数据类型</h4><table><thead><tr><th align="left">类型</th><th align="left">关键字</th></tr></thead><tbody><tr><td align="left">布尔型</td><td align="left">bool</td></tr><tr><td align="left">字符型</td><td align="left">char</td></tr><tr><td align="left">整型</td><td align="left">int</td></tr><tr><td align="left">浮点型</td><td align="left">float</td></tr><tr><td align="left">双浮点型</td><td align="left">double</td></tr><tr><td align="left">无类型</td><td align="left">void</td></tr><tr><td align="left">宽字符型</td><td align="left">wchar_t (本质是short int)</td></tr></tbody></table><p>一些基本类型可以使用一个或多个类型修饰符进行修饰, 类型修饰符包括 signed,unsigned,short,long</p><p>添加修饰符后的数据类型效果是这样的:   (具体数据会根据编译器不同和不同系统有所差异)</p><table><thead><tr><th align="left">类型</th><th align="left">位</th><th align="left">范围</th></tr></thead><tbody><tr><td align="left">char</td><td align="left">1 个字节</td><td align="left">-128 到 127 或者 0 到 255</td></tr><tr><td align="left">unsigned char</td><td align="left">1 个字节</td><td align="left">0 到 255</td></tr><tr><td align="left">signed char</td><td align="left">1 个字节</td><td align="left">-128 到 127</td></tr><tr><td align="left">int</td><td align="left">4 个字节</td><td align="left">-2147483648 到 2147483647</td></tr><tr><td align="left">unsigned int</td><td align="left">4 个字节</td><td align="left">0 到 4294967295</td></tr><tr><td align="left">signed int</td><td align="left">4 个字节</td><td align="left">-2147483648 到 2147483647</td></tr><tr><td align="left">short int</td><td align="left">2 个字节</td><td align="left">-32768 到 32767</td></tr><tr><td align="left">unsigned short int</td><td align="left">2 个字节</td><td align="left">0 到 65,535</td></tr><tr><td align="left">signed short int</td><td align="left">2 个字节</td><td align="left">-32768 到 32767</td></tr><tr><td align="left">long int</td><td align="left">8 个字节</td><td align="left">-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td></tr><tr><td align="left">signed long int</td><td align="left">8 个字节</td><td align="left">-9,223,372,036,854,775,808 到 9,223,372,036,854,775,807</td></tr><tr><td align="left">unsigned long int</td><td align="left">8 个字节</td><td align="left">0 到 18,446,744,073,709,551,615</td></tr><tr><td align="left">float</td><td align="left">4 个字节</td><td align="left">精度型占4个字节（32位）内存空间，+/- 3.4e +/- 38 (~7 个数字)</td></tr><tr><td align="left">double</td><td align="left">8 个字节</td><td align="left">双精度型占8 个字节（64位）内存空间，+/- 1.7e +/- 308 (~15 个数字)</td></tr><tr><td align="left">long double</td><td align="left">16 个字节</td><td align="left">长双精度型 16 个字节（128位）内存空间，可提供18-19位有效数字。</td></tr><tr><td align="left">wchar_t</td><td align="left">2 或 4 个字节</td><td align="left">1 个宽字符</td></tr></tbody></table><p>具体的判断似乎可以通过下列代码来完成,但是有些数据类型我没有运行通过</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;limits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;  </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">bool</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 所占字节数</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (numeric_limits&lt;<span class="keyword">bool</span>&gt;::max)() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 最大值</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (numeric_limits&lt;<span class="keyword">bool</span>&gt;::min)() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 最小值</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="枚举类型"><a href="#枚举类型" class="headerlink" title="枚举类型:"></a>枚举类型:</h4><p>在cpp中,枚举类型是一种真正的类型,形式如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> &lt;</span>表示符&gt; &#123;&lt;枚举列表&gt;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Color</span> &#123;</span>Red, Green, Yellow&#125;;</span><br></pre></td></tr></table></figure><p>其中,enum是枚举类型标识,枚举列表定义了该枚举类型的所有枚举值.<br>定义枚举类型之后,就可以定义该枚举类型的变量.枚举类型的变量只允许赋值操作:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Color myColor;</span><br><span class="line">myColor = Yellow; <span class="comment">// 对枚举类型执行赋值操作</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;myColor&lt;&lt;<span class="built_in">endl</span>; <span class="comment">// 结果为2 对应的是序号2,说明存储的是符号数字常量2</span></span><br></pre></td></tr></table></figure><p>详细参考菜鸟教程 <a href="https://www.runoob.com/w3cnote/cpp-enum-intro.html">https://www.runoob.com/w3cnote/cpp-enum-intro.html</a></p><h4 id="结构体数据类型"><a href="#结构体数据类型" class="headerlink" title="结构体数据类型:"></a>结构体数据类型:</h4><p>大致与c语言相同,比c更加简单,结构体一旦定义,就可以用来定义变量,而不用加标识符struct,</p><p>在cpp中,结构体相当于没有私有成员的类, 不过struct中是可以定义方法的,静态和成员都可以)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">struct Student&#123;</span><br><span class="line">    long number;</span><br><span class="line">    char name[10];</span><br><span class="line">    char sex[4];</span><br><span class="line">    int age;</span><br><span class="line">    static void hello()&#123;</span><br><span class="line">    cout&lt;&lt;&quot;hello world&quot;&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">Student student &#x3D; &#123;100001, &quot;张三&quot;, &quot;男&quot;, 26&#125;,y&#123;&#125;,z&#123;&#125;,*p; &#x2F;&#x2F; 将Student 实例化4个</span><br><span class="line">&#x2F;&#x2F; 另, 由于clang-tidy的事, 实例化空的时候也带上括号,但是不带括号也行.</span><br><span class="line">y.number &#x3D; student.number; &#x2F;&#x2F; 等号赋值</span><br><span class="line">p &#x3D; &amp;student; &#x2F;&#x2F; 地址赋值</span><br><span class="line">z.number &#x3D; p-&gt;number; &#x2F;&#x2F; 指针赋值</span><br><span class="line">Student::hello();</span><br></pre></td></tr></table></figure><h4 id="typedef-创造数据类型"><a href="#typedef-创造数据类型" class="headerlink" title="typedef 创造数据类型:"></a>typedef 创造数据类型:</h4><p>定义后, bs就是int的另一个名称</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typedef int bs; </span><br></pre></td></tr></table></figure><p>如此就可以创建一个整型变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bs L;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> cpp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cv2 中文路径打开失败</title>
      <link href="/new/2021/02/25/cv2%E4%B8%AD%E6%96%87%E8%B7%AF%E5%BE%84%E6%89%93%E5%BC%80%E5%A4%B1%E8%B4%A5/"/>
      <url>/new/2021/02/25/cv2%E4%B8%AD%E6%96%87%E8%B7%AF%E5%BE%84%E6%89%93%E5%BC%80%E5%A4%B1%E8%B4%A5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>工具函数解决问题:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def cv_read(file_path):</span><br><span class="line">    cv_img &#x3D; cv2.imdecode(np.fromfile(file_path, dtype&#x3D;np.uint8), -1)</span><br><span class="line">    return cv_img</span><br></pre></td></tr></table></figure><p><a href="https://www.zhihu.com/question/67157462">https://www.zhihu.com/question/67157462</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> opencv cv2 python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pyqt5 QLabel</title>
      <link href="/new/2021/02/14/pyqt5-QLabel/"/>
      <url>/new/2021/02/14/pyqt5-QLabel/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="常用信号"><a href="#常用信号" class="headerlink" title="常用信号"></a>常用信号</h3><table><thead><tr><th>信号</th><th>描述</th></tr></thead><tbody><tr><td>linkActivated</td><td>当单击标签中嵌入的超链接,希望在新窗口中打开这个超链接时,setOpenExternalLinks特性必须设置为true</td></tr><tr><td>linkHovered</td><td>当指针划过时候触发</td></tr></tbody></table><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>setAlignment()</td><td>设置文本对齐方式,可设置的有<br /> - Qt.AlignLeft Qt.AlignRight Qt.AlignCenter水平方向左右中对齐<br /> -  Qt.AlignJustify 水平方向调整间距两端对齐</td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr><tr><td></td><td></td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> pyqt5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用pyuic5工具将调用ui文件转换为python类</title>
      <link href="/new/2021/02/13/%E4%BD%BF%E7%94%A8pyuic5%E5%B7%A5%E5%85%B7%E5%B0%86%E8%B0%83%E7%94%A8ui%E6%96%87%E4%BB%B6%E8%BD%AC%E6%8D%A2%E4%B8%BApython%E7%B1%BB/"/>
      <url>/new/2021/02/13/%E4%BD%BF%E7%94%A8pyuic5%E5%B7%A5%E5%85%B7%E5%B0%86%E8%B0%83%E7%94%A8ui%E6%96%87%E4%BB%B6%E8%BD%AC%E6%8D%A2%E4%B8%BApython%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="原有代码"><a href="#原有代码" class="headerlink" title="原有代码"></a>原有代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QApplication, QMainWindow</span><br><span class="line"><span class="keyword">from</span> PyQt5.uic <span class="keyword">import</span> loadUi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainWindow</span>(<span class="params">QMainWindow</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, parent=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>(MainWindow, self).__init__(parent)</span><br><span class="line">        loadUi(<span class="string">&#x27;main.ui&#x27;</span>, self)</span><br><span class="line">        self.refresh.clicked.connect(self.refresh1)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">refresh1</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.output1.setText(<span class="string">&quot;dsafasdf&quot;</span>)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">app = QApplication(sys.argv)</span><br><span class="line">w = MainWindow()</span><br><span class="line">w.show()</span><br><span class="line">sys.exit(app.exec())</span><br></pre></td></tr></table></figure><h1 id="ui文件生成python类"><a href="#ui文件生成python类" class="headerlink" title="ui文件生成python类"></a>ui文件生成python类</h1><p>在电脑中找到pyuic5.exe可执行文件,在cmd中输入 D:/…/pyuic5.exe xxx.ui,会得到转换完成的python类,如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PyQt5 <span class="keyword">import</span> QtCore, QtGui, QtWidgets</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QMainWindow</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Ui_MainWindow</span>(<span class="params">QMainWindow</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setupUi</span>(<span class="params">self, MainWindow</span>):</span></span><br><span class="line">        MainWindow.setObjectName(<span class="string">&quot;MainWindow&quot;</span>)</span><br><span class="line">        MainWindow.resize(<span class="number">943</span>, <span class="number">736</span>)</span><br><span class="line">        self.centralwidget = QtWidgets.QWidget(MainWindow)</span><br><span class="line">        self.centralwidget.setObjectName(<span class="string">&quot;centralwidget&quot;</span>)</span><br></pre></td></tr></table></figure><h1 id="生成的python类与原有代码合并"><a href="#生成的python类与原有代码合并" class="headerlink" title="生成的python类与原有代码合并"></a>生成的python类与原有代码合并</h1><ul><li><p>删除loadui行</p></li><li><p>使原有代码的类 继承 生成代码的类</p></li><li><p>原有代码的__init__方法,参数修改为(self), __init__方法增加如下三行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">super</span>(ui.Ui_MainWindow, self).__init__()</span><br><span class="line">self.setupUi(self)</span><br><span class="line">self.retranslateUi(self)</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> pyqt5 </tag>
            
            <tag> qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS快速查询笔记</title>
      <link href="/new/2021/02/13/web/CSS%E5%BF%AB%E9%80%9F%E6%9F%A5%E8%AF%A2/"/>
      <url>/new/2021/02/13/web/CSS%E5%BF%AB%E9%80%9F%E6%9F%A5%E8%AF%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="css属性"><a href="#css属性" class="headerlink" title="css属性"></a>css属性</h3><h4 id="权重分配"><a href="#权重分配" class="headerlink" title="权重分配"></a>权重分配</h4><p>css权重 内联&gt;id&gt;class&gt;标签和通配符</p><h4 id="附加注意"><a href="#附加注意" class="headerlink" title="附加注意"></a>附加注意</h4><p>em 相对单位,相对于最近的父元素的字号大小变化而变化, 但是 本身,子类字号就是跟着父类走的</p><h4 id="文本css"><a href="#文本css" class="headerlink" title="文本css"></a>文本css</h4><p>字体颜色 color:red;<br>字体大小 font-size:16px; 字体的默认大小是16px<br>字体的水平对齐方式: text-align:left/center/right<br>字体 font-family 可以设置多种字体,从第一个开始适配<br>字体粗细 font-weight bold/normal(默认normal)之类的,或者用100-900表示,500等价于normal<br>文字倾斜 font-style normal不倾斜 italic倾斜<br>水平对齐方式 text-aligin left/right/center/justify(两端对齐)</p><h4 id="背景css"><a href="#背景css" class="headerlink" title="背景css"></a>背景css</h4><p>background-color: 颜色<br>background-image: 背景图<br>background-repeat: 重复 可x方向重复,y方向重复,还有no-repeat</p><p>background-size: cover表示完全覆盖  图片大小<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-size">https://developer.mozilla.org/zh-CN/docs/Web/CSS/background-size</a><br>background-attachment: fixed 背景固定,就是不随滑动条滑动</p><h4 id="列表CSS"><a href="#列表CSS" class="headerlink" title="列表CSS"></a>列表CSS</h4><p>list-style:none;  去掉小黑点或者数字</p><h4 id="其他css"><a href="#其他css" class="headerlink" title="其他css"></a>其他css</h4><p>宽度 width<br>高度 height</p><h4 id="浮动css属性"><a href="#浮动css属性" class="headerlink" title="浮动css属性"></a>浮动css属性</h4><p>1,浮动的框可以向左或向右移动，直到它的外边缘碰到包含框或另一个浮动框的边框为止。2,由于浮动框不在文档的普通流中，所以文档的普通流中的块框表现得就像浮动框不存在一样。</p><p>用途: </p><p>1, 图文排版</p><p>2.竖着的元素横着排列: 比如全体float:left 然后加一个父类,给父类设置高度使得下一个元素不会串上来</p><h3 id="W3C盒模型"><a href="#W3C盒模型" class="headerlink" title="W3C盒模型"></a>W3C盒模型</h3><p>内容-padding-border-margin</p><h4 id="margin"><a href="#margin" class="headerlink" title="margin:"></a>margin:</h4><p>1, 一共四个, margin-left / margin-right /  margin-top / margin-bottom</p><p>简写:  </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">margin</span>: 80<span class="selector-tag">px</span> 30<span class="selector-tag">px</span> 50<span class="selector-tag">px</span> 50<span class="selector-tag">px</span> (顺时针 上右下左)</span><br><span class="line"><span class="selector-tag">margin</span>: 80<span class="selector-tag">px</span> 30<span class="selector-tag">px</span> (上下 <span class="selector-tag">-</span> 左右)</span><br><span class="line"><span class="selector-tag">margin</span>: 30<span class="selector-tag">px</span> (所有)</span><br></pre></td></tr></table></figure><p>2, 可以用margin来做水平居中:</p><p>只能用在有宽度 并且宽度生效的元素(大标签) 做水平居中</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">margin</span>: 0 <span class="selector-tag">auto</span>;</span><br></pre></td></tr></table></figure><h4 id="border"><a href="#border" class="headerlink" title="border:"></a>border:</h4><p>以下三条最好一起出现</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">border-color</span>: 边框颜色</span><br><span class="line"><span class="selector-tag">border-width</span>: 边框宽度</span><br><span class="line"><span class="selector-tag">border-style</span>: 边框样式 (可选值: 实线<span class="selector-tag">solid</span> 虚线<span class="selector-tag">dashed</span> 点划线<span class="selector-tag">dotted</span> 双线<span class="selector-tag">double</span>)</span><br></pre></td></tr></table></figure><p>简写: </p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">border</span>: <span class="selector-tag">red</span> 10<span class="selector-tag">px</span> <span class="selector-tag">solid</span>; (顺序随便)</span><br></pre></td></tr></table></figure><p>注意 边框会加在原有元素外,使原有元素的宽高撑大. 所以可以考虑把元素变小一点</p><p>栗子 用边框画三角形: (原理是两个相邻的边框是不同颜色的时候,交叉的部分是一条斜线分开的)</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">        <span class="attribute">border</span>: <span class="number">20px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-top-color</span>: red;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;box&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="padding"><a href="#padding" class="headerlink" title="padding:"></a>padding:</h4><h4 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h4><p>1, 子元素设置margin top的时候会使父元素整体下移,可在父元素上设置overflow:hidden来避免</p>]]></content>
      
      
      
        <tags>
            
            <tag> web </tag>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pyqt5调用ui文件作为主界面</title>
      <link href="/new/2021/02/12/pyqt5%E8%B0%83%E7%94%A8ui%E6%96%87%E4%BB%B6%E4%BD%9C%E4%B8%BA%E4%B8%BB%E7%95%8C%E9%9D%A2/"/>
      <url>/new/2021/02/12/pyqt5%E8%B0%83%E7%94%A8ui%E6%96%87%E4%BB%B6%E4%BD%9C%E4%B8%BA%E4%B8%BB%E7%95%8C%E9%9D%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="最简单版"><a href="#最简单版" class="headerlink" title="最简单版"></a>最简单版</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">from</span> PyQt5.QtWidgets <span class="keyword">import</span> QApplication, QMainWindow</span><br><span class="line"><span class="keyword">from</span> PyQt5.uic <span class="keyword">import</span> loadUi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainWindow</span>(<span class="params">QMainWindow</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, parent=<span class="literal">None</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>(MainWindow, self).__init__(parent)</span><br><span class="line">        loadUi(<span class="string">&#x27;main.ui&#x27;</span>, self)</span><br><span class="line">        self.refresh.clicked.connect(self.refresh1)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">refresh1</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.output1.setText(<span class="string">&quot;dsafasdf&quot;</span>)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">app = QApplication(sys.argv)</span><br><span class="line">w = MainWindow()</span><br><span class="line">w.show()</span><br><span class="line">sys.exit(app.exec())</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> pyqt5 </tag>
            
            <tag> qt </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>完整的reg操作注册表</title>
      <link href="/new/2021/02/10/%E5%AE%8C%E6%95%B4%E7%9A%84reg%E6%93%8D%E4%BD%9C%E6%B3%A8%E5%86%8C%E8%A1%A8/"/>
      <url>/new/2021/02/10/%E5%AE%8C%E6%95%B4%E7%9A%84reg%E6%93%8D%E4%BD%9C%E6%B3%A8%E5%86%8C%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css">]]></content>
      
      
      
        <tags>
            
            <tag> windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CMD检查本地端口被占用情况</title>
      <link href="/new/2021/02/10/CMD%E6%A3%80%E6%9F%A5%E6%9C%AC%E5%9C%B0%E7%AB%AF%E5%8F%A3%E8%A2%AB%E5%8D%A0%E7%94%A8%E6%83%85%E5%86%B5/"/>
      <url>/new/2021/02/10/CMD%E6%A3%80%E6%9F%A5%E6%9C%AC%E5%9C%B0%E7%AB%AF%E5%8F%A3%E8%A2%AB%E5%8D%A0%E7%94%A8%E6%83%85%E5%86%B5/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul><li>扫描所有端口</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano</span><br></pre></td></tr></table></figure><ul><li>扫描所有端口并在结果中搜索字符串</li></ul><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">netstat -ano | <span class="built_in">findstr</span> &quot;:<span class="number">800</span>&quot;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在右键菜单中添加复制文件名或者路径的功能(原理)</title>
      <link href="/new/2021/02/10/Right-Menu-To-Copy-Path-principle/"/>
      <url>/new/2021/02/10/Right-Menu-To-Copy-Path-principle/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="简单添加右键菜单并执行指令"><a href="#简单添加右键菜单并执行指令" class="headerlink" title="简单添加右键菜单并执行指令"></a>简单添加右键菜单并执行指令</h3><p>1, Win+R regedit 启动注册表<br>2, 这里以文件右键菜单为例,在注册表中打开一下目录:</p><img src="image-20210210152826142.png" alt="image-20210210152826142" style="zoom:67%;" /><p>可以看到,Path就是我添加进去的,右键菜单中的选项,新建Path之后,就可以看到文件的右键菜单有了”Path”字样</p><p>3,如果想把Path当成父目录,下设一级菜单的话,在path下新建如图所示键值:</p><img src="image-20210210153137525.png" alt="image-20210210153137525" style="zoom: 50%;" /><p>并下设shell键,shell键不用设置任何内容</p><img src="image-20210210153234690.png" alt="image-20210210153234690" style="zoom: 67%;" /><p>4,shell下设的内容就是下一级菜单内容,这里我设置了三个,shell键和下设的三个键不用设置任何值</p><p>5,三个键,比如File Name,本身不设键值,要下设一个键,键名为command,一定要是command,command键的默认键值的数据字段为要执行的内容</p><img src="image-20210210153507605.png" alt="image-20210210153507605" style="zoom: 67%;" /><p>一般由xxx.exe和参数构成, %1表示右键选择的文件路径和文件名</p><h3 id="注册表与菜单的对应关系"><a href="#注册表与菜单的对应关系" class="headerlink" title="注册表与菜单的对应关系"></a>注册表与菜单的对应关系</h3><p>上一个大标题的对应的是文件右键的菜单</p><p>文件夹右键的内容是不在上面的</p><p>文件夹右键的菜单在这里:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hkcr\Directory\shell\Path</span><br></pre></td></tr></table></figure><h3 id="reg操作注册表"><a href="#reg操作注册表" class="headerlink" title="reg操作注册表"></a>reg操作注册表</h3><p>windows中有一个可执行文件,叫reg.exe,提供了操作注册表的办法.</p><p>详细讲好多嘞,简单举个例子:</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg.exe add hkcr\*\shell\<span class="built_in">Path</span> /v SubCommands /t REG_SZ</span><br></pre></td></tr></table></figure><p>👆 hhkr指HKEY_CLASSES_ROOT,其他缩写可以百度,add表示添加,”/v SubCommands /t REG_SZ”表示类型为REG_SZ,名称为SubCommands的键,内容为空.如果想设置内容,就在后面加一段 /d xxx</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg.exe add hkcr\*\shell\<span class="built_in">Path</span>\shell\&quot;File Name&quot;\command /ve /t REG_SZ /d $exePath&quot; name &#x27;%<span class="number">1</span>&#x27; &quot;</span><br></pre></td></tr></table></figure><p>👆 巩固一下,这句话的意思是,add添加,hkcr*\shell\Path\shell&quot;File Name”\command键的值, 这里是/ve,是一个特殊的/v属性,表示默认参数,这句话的意思是,默认参数为,REG_SZ类型的 数据为$exePath” name ‘%1’ “的键值.</p><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reg.exe delete hkcr\*\shell\<span class="built_in">Path</span> /f</span><br></pre></td></tr></table></figure><p>👆这是删除,上面的add表示添加,对应的就是删除, /f指令表示force,如果没有/f参数,是需要二次确认的,完整命令的意思就是,删除hkcr*\shell\Path键,不提示直接删除</p><h3 id="获取文件名并输出到剪贴板"><a href="#获取文件名并输出到剪贴板" class="headerlink" title="获取文件名并输出到剪贴板"></a>获取文件名并输出到剪贴板</h3><p>上面提到的指令,中的%1就是完整的路径文件名,传入exe中作为一个参数出现的,那么这个exe处理这个参数就可以了</p><p>下面这个是python的实现方法,python确实效率不高,打包之后有6M左右,以后有机会再换C实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">import</span> win32clipboard <span class="keyword">as</span> w</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(sys.argv)&lt;<span class="number">3</span>:</span><br><span class="line">    quit()</span><br><span class="line"></span><br><span class="line">args = sys.argv</span><br><span class="line">fullPathName = args[<span class="number">2</span>][<span class="number">1</span>:-<span class="number">1</span>]</span><br><span class="line"><span class="comment"># 当最后一个是斜杠的时候会有问题,但是暂时没出现最后是斜杠的情况</span></span><br><span class="line"><span class="keyword">if</span> args[<span class="number">1</span>]==<span class="string">&quot;name&quot;</span>:</span><br><span class="line">    cp = fullPathName.split(<span class="string">&quot;\\&quot;</span>)[-<span class="number">1</span>]</span><br><span class="line"><span class="keyword">elif</span> args[<span class="number">1</span>]==<span class="string">&quot;pathu&quot;</span>:</span><br><span class="line">    cp = fullPathName</span><br><span class="line"><span class="keyword">elif</span> args[<span class="number">1</span>]==<span class="string">&quot;pathd&quot;</span>:</span><br><span class="line">    cp = fullPathName.replace(<span class="string">&quot;\\&quot;</span>,<span class="string">&quot;/&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># print(cp)</span></span><br><span class="line"></span><br><span class="line">w.OpenClipboard()</span><br><span class="line">w.EmptyClipboard()</span><br><span class="line">w.SetClipboardText(cp)</span><br><span class="line">w.CloseClipboard()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> windows </tag>
            
            <tag> python </tag>
            
            <tag> 小工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在右键菜单中添加复制文件名或者路径的功能(使用说明)</title>
      <link href="/new/2021/02/10/Right-Menu-To-Copy-Path/"/>
      <url>/new/2021/02/10/Right-Menu-To-Copy-Path/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法:"></a>安装方法:</h3><p><a href="https://github.com/zephms/Right-Menu-To-Copy-Path/releases/download/v0.1/Windows.zip">点击下载</a></p><p>解压Windows.zip,将其中的exe文件放在一个合适的位置(可以根据需要更改文件名)</p><p>然后用记事本或其他文本编辑器打开install.ps1,将下面引号中的exe路径改为上一步放的位置</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$exePath</span> = <span class="string">&quot;D:\xxx\rightClick.exe&quot;</span></span><br></pre></td></tr></table></figure><p>在install.ps1所在目录启动powershell,输入:</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./install.ps1</span><br></pre></td></tr></table></figure><p>若没有报错的话,就已经安装好了,exe文件不要随意动,如果动了,需要重新更改install脚本中的文件路径,并安装,不过此时会提示覆盖安装,选择yes就好了. 至于install和uninstall两个脚本,动倒无所谓,别丢了就行,还得下载</p><h3 id="卸载"><a href="#卸载" class="headerlink" title="卸载:"></a>卸载:</h3><p>用和install.ps1同样的方法,执行uninstall</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./uninstall.ps1</span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h3><p>目前,多文件选中时,仅复制一个文件的文件名,有啥建议可以来GitHub提issue :)</p><p><a href="https://github.com/zephms/Right-Menu-To-Copy-Path/">zephms/Right-Menu-To-Copy-Path: 给右键菜单添加复制文件名或者路径的功能 (github.com)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> windows </tag>
            
            <tag> python </tag>
            
            <tag> 小工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令行中使用代理</title>
      <link href="/new/2021/02/07/%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86/"/>
      <url>/new/2021/02/07/%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%AD%E4%BD%BF%E7%94%A8%E4%BB%A3%E7%90%86/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h5 id="注意-测试代理可用不可用-不要用ping命令-而要使用curl命令-如"><a href="#注意-测试代理可用不可用-不要用ping命令-而要使用curl命令-如" class="headerlink" title="注意:测试代理可用不可用,不要用ping命令,而要使用curl命令,如"></a>注意:测试代理可用不可用,不要用ping命令,而要使用curl命令,如</h5><ul><li><h3 id="针对cmd"><a href="#针对cmd" class="headerlink" title="针对cmd"></a>针对cmd</h3></li></ul><p>在VPN软件中设置一个端口,这里以ssr代理,1080端口为例</p><img src="image-20201212210926621.png" alt="image-20201212210926621" style="zoom:67%;" /><p>在cmd中执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">set</span> http_proxy=http://127.0.0.1:1080</span><br><span class="line"><span class="built_in">set</span> https_proxy=https://127.0.0.1:1080</span><br></pre></td></tr></table></figure><ul><li><h3 id="针对powershell"><a href="#针对powershell" class="headerlink" title="针对powershell"></a>针对powershell</h3></li></ul><p>powershell走的是网络层, 正好能被SSR、SS或V2Ray代理，不用手动设置了, 而无需手动设置代理</p><p>但是要是想代理,也不是不行</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$env:http_proxy</span>=<span class="string">&quot;http://127.0.0.1:1080&quot;</span></span><br><span class="line"><span class="variable">$env:https_proxy</span>=<span class="string">&quot;http://127.0.0.1:1080&quot;</span></span><br></pre></td></tr></table></figure><ul><li><h3 id="git-bash"><a href="#git-bash" class="headerlink" title="git bash"></a>git bash</h3></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git config --global https.proxy http://127.0.0.1:1080</span><br><span class="line">git config --global https.proxy https://127.0.0.1:1080</span><br><span class="line">git config --global http.proxy <span class="string">&#x27;socks5://127.0.0.1:1080&#x27;</span> </span><br><span class="line">git config --global https.proxy <span class="string">&#x27;socks5://127.0.0.1:1080&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过socket进行本地的进程间通信</title>
      <link href="/new/2021/02/06/%E9%80%9A%E8%BF%87socket%E8%BF%9B%E8%A1%8C%E6%9C%AC%E5%9C%B0%E7%9A%84%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/"/>
      <url>/new/2021/02/06/%E9%80%9A%E8%BF%87socket%E8%BF%9B%E8%A1%8C%E6%9C%AC%E5%9C%B0%E7%9A%84%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>我的一个python程序需要写一个界面,最终定的是逻辑使用python,界面使用electron进行开发,electron的逻辑是由node来解释执行的,所以我把python作为node的一个子线程,node进程和python进程之间使用socket进行通信.</p><h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>我需要一个进程等待另一个进程下达指令,接收到指令后,分析并执行,然后给出返回值</p><img src="image-20210206190449967.png" alt="image-20210206190449967" style="zoom: 67%;" /><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>socket的原理简单来说,就是插头和插座, 一个插座可以由任意一个插头插上,插上就可以导电了. 同样,在socket中分为服务器端和客户端,服务器端进行监听,服务端在需要的时候发送数据包到服务端,服务端处理请求,将返回值返回给客户端.</p><p>当然,socket的运行,是需要借用一个端口的,服务端基于端口进行监听,客户端向端口发送数据.</p><p>由于通信协议,这些数据在传输的时候是以字节进行传输的,在python中体现为byte类型,在node中体现为buffer,用这种类型确实可以方便我们精确控制每一个字节传输的内容,而且如果合理利用可以提高传输效率.但是我考虑到byte类型与顶层逻辑之间转换的麻烦,决定使用字符串进行传输,按utf8进行编码.</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>服务端:</p><p>服务端处理数据,我设置了一个表示处理数据的函数analysis,这个函数接收一个字符串类型的参数,处理,并返回一个字符串类型的参数.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务端代码 python版</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">analysis</span>(<span class="params">str_</span>):</span></span><br><span class="line">    print(str_)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hhh,&quot;</span>+str_</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">host = <span class="string">&quot;&quot;</span></span><br><span class="line">port = <span class="number">800</span></span><br><span class="line">address = (host, port)</span><br><span class="line">time_now = time.strftime(<span class="string">&quot;%Y-%m-%d %H:%S:%M&quot;</span>, time.localtime())</span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">s.bind(address)</span><br><span class="line">s.listen(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    print(<span class="string">&quot;Waiting for connections...&quot;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        client_connection, client_address = s.accept()</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        <span class="keyword">raise</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        traceback.print_exc()</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;Got connection from&quot;</span>, client_connection.getpeername())</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># client_connection.settimeout(5)</span></span><br><span class="line">            buf = client_connection.recv(<span class="number">1024</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(buf) == <span class="number">0</span>: <span class="comment"># break,跳出while循环</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                client_connection.send(<span class="built_in">bytes</span>(analysis(buf.decode()), encoding=<span class="string">&quot;utf8&quot;</span>))  </span><br><span class="line">    <span class="keyword">except</span> (KeyboardInterrupt, SystemError):</span><br><span class="line">        <span class="keyword">raise</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        traceback.print_exc()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    client_connection.close()</span><br><span class="line"><span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">    <span class="keyword">raise</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    traceback.print_exc()</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端代码,node版</span></span><br><span class="line"><span class="comment">// 1 引入模块</span></span><br><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">&quot;net&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> analysis = <span class="function"><span class="keyword">function</span>(<span class="params">str_</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;hhh, &quot;</span>+ str_;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2 创建服务器</span></span><br><span class="line"><span class="keyword">let</span> clientArr = [];</span><br><span class="line"><span class="keyword">const</span> server = net.createServer();</span><br><span class="line"><span class="comment">// 3 绑定链接事件</span></span><br><span class="line">server.on(<span class="string">&quot;connection&quot;</span>, <span class="function">(<span class="params">person</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(clientArr.length);</span><br><span class="line">  <span class="comment">// 记录链接的进程</span></span><br><span class="line">  person.id = clientArr.length;</span><br><span class="line">  clientArr.push(person);</span><br><span class="line">  person.setEncoding(<span class="string">&quot;utf8&quot;</span>);</span><br><span class="line">  <span class="comment">// 客户socket进程绑定事件</span></span><br><span class="line">  person.on(<span class="string">&quot;data&quot;</span>, <span class="function">(<span class="params">chunk</span>) =&gt;</span> &#123;</span><br><span class="line">    clientArr.forEach(<span class="function">(<span class="params">val</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 数据写入全部客户进程中</span></span><br><span class="line">      <span class="comment">//////////// 数据在这里处理</span></span><br><span class="line">      val.write(analysis(chunk));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  person.on(<span class="string">&quot;close&quot;</span>, <span class="function">(<span class="params">p1</span>) =&gt;</span> &#123;</span><br><span class="line">    clientArr[p1.id] = <span class="literal">null</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  person.on(<span class="string">&quot;error&quot;</span>, <span class="function">(<span class="params">p1</span>) =&gt;</span> &#123;</span><br><span class="line">    clientArr[p1.id] = <span class="literal">null</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">server.listen(<span class="number">800</span>);</span><br></pre></td></tr></table></figure><p>客户端:</p><p>客户端由一个csend函数,csend函数唯一的参数就是发送的数据,返回值是从服务器端返回的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 客户端代码, python版</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">host = <span class="string">&quot;localhost&quot;</span></span><br><span class="line">port = <span class="number">800</span></span><br><span class="line">address = (host, port)</span><br><span class="line"></span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">s.connect(address)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">csend</span>(<span class="params">mes</span>):</span></span><br><span class="line">    s.send(<span class="built_in">bytes</span>(mes, encoding=<span class="string">&quot;utf8&quot;</span>))</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        buf = s.recv(<span class="number">1024</span>)</span><br><span class="line">        <span class="keyword">return</span> buf.decode()</span><br><span class="line">    <span class="keyword">except</span> e:</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;Error receiving :&quot;</span>, e)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span></span><br><span class="line">        <span class="comment">#sys.exit(1) # 终止程序用</span></span><br><span class="line"></span><br><span class="line">mes = <span class="string">&quot;hello world&quot;</span></span><br><span class="line">print(csend(mes))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">s.shutdown(socket.SHUT_WR)</span><br><span class="line">s.close()</span><br></pre></td></tr></table></figure><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端代码, node版</span></span><br><span class="line"><span class="comment">// 1 引入模块</span></span><br><span class="line"><span class="keyword">const</span> net = <span class="built_in">require</span>(<span class="string">&quot;net&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> readline = <span class="built_in">require</span>(<span class="string">&quot;readline&quot;</span>);</span><br><span class="line"><span class="comment">// 2 创建套接字和输入输出命令行</span></span><br><span class="line"><span class="keyword">let</span> rl = readline.createInterface(&#123;</span><br><span class="line">  <span class="comment">// 调用std接口</span></span><br><span class="line">  input: process.stdin,</span><br><span class="line">  output: process.stdout,</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> client = <span class="keyword">new</span> net.Socket();</span><br><span class="line"><span class="comment">// 3 链接</span></span><br><span class="line">client.connect(<span class="number">800</span>, <span class="string">&quot;localhost&quot;</span>);</span><br><span class="line"></span><br><span class="line">client.setEncoding(<span class="string">&quot;utf8&quot;</span>);</span><br><span class="line"><span class="comment">// 绑定输io流事件,获取输入输出字符</span></span><br><span class="line"><span class="comment">// rl.on(&#x27;line&#x27;,(mes)=&gt;&#123;</span></span><br><span class="line"><span class="comment">// client.write(mes);</span></span><br><span class="line"><span class="comment">// &#125;)</span></span><br><span class="line"></span><br><span class="line">client.on(<span class="string">&#x27;data&#x27;</span>, <span class="function">(<span class="params">data</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">client.on(<span class="string">&quot;error&quot;</span>, <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(e.message);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">csend</span>(<span class="params">mes</span>) </span>&#123;</span><br><span class="line">  client.write(mes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">csend(<span class="string">&quot;hello world&quot;</span>);</span><br></pre></td></tr></table></figure><h3 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h3><p>服务端二选一,运行起来,然后执行客户端代码,客户端也是二选一,运行之后控制台会有输出</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>由于我的python进程需要执行很长时间,因此python部分加入了多线程,一下就是举个例子,似乎不是那么有通用性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> traceback</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">此文件作为python后台的控制中心</span></span><br><span class="line"><span class="string">接收并处理 来自前端和子python进程 的指令 并 启动子线程完成任务</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">注,暂时子python进程可以直接向前端发送数据,也可以向此父进程发送数据再转发, 看开发者心情</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">接收信息格式: json字符串</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    &quot;command&quot;:&quot;online_check_in&quot; // 必须</span></span><br><span class="line"><span class="string">    &quot;其他&quot;:...  // 其他根据情况选择</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">子进程未设置推出,估计会自动退出,后续解决</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">thread_template</span>(<span class="params">threading.Thread</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, threadID, name, get</span>):</span></span><br><span class="line">        threading.Thread.__init__(self)</span><br><span class="line">        self.threadID = threadID</span><br><span class="line">        self.name = name</span><br><span class="line">        self.get = get</span><br><span class="line">        self.command = get.get(<span class="string">&quot;command&quot;</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;开启线程： &quot;</span> + self.name)</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;此线程执行的指令为&quot;</span>, self.command)</span><br><span class="line">        <span class="comment"># 此处的get为字典类型,具有command字段,其他字段由传入决定</span></span><br><span class="line">        <span class="keyword">if</span> self.command == <span class="string">&quot;online_check_in&quot;</span>:</span><br><span class="line">            <span class="comment"># camera.m()</span></span><br><span class="line">            <span class="comment">####################<span class="doctag">TODO:</span> 在此处执行此时的方法,可以用全局方法,推荐使用类方法</span></span><br><span class="line">            <span class="comment">#<span class="doctag">TODO:</span>执行线上点名的python脚本</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">elif</span> self.command == <span class="string">&quot;offline_check_in&quot;</span>:</span><br><span class="line">            <span class="comment"># todo:执行线下点名的python脚本</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">elif</span> self.command == <span class="string">&quot;online_check_behavior&quot;</span>:</span><br><span class="line">            <span class="comment"># todo:执行线上行为检测的python脚本</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">elif</span> self.command == <span class="string">&quot;offline_check_behavior_danger&quot;</span>:</span><br><span class="line">            <span class="comment"># todo:执行线下危险行为检测的python脚本</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">elif</span> self.command == <span class="string">&quot;offline_check_behavior_state&quot;</span>:</span><br><span class="line">            <span class="comment"># todo:执行线下状态检测的python脚本</span></span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">elif</span> self.command == <span class="string">&quot;record_face&quot;</span>:</span><br><span class="line">            camera.m()</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            print(<span class="string">&quot;出现了意想不到的情况&quot;</span>)</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line">        <span class="comment"># 获取锁，用于线程同步</span></span><br><span class="line">        <span class="comment"># threadLock.acquire()</span></span><br><span class="line">        self.print_time(self.name, self.counter, <span class="number">3</span>)</span><br><span class="line">        <span class="comment"># 释放锁，开启下一个线程</span></span><br><span class="line">        <span class="comment"># threadLock.release()</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_time</span>(<span class="params">self, threadName, delay, counter</span>):</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">            print(self.threadID, time.gmtime())</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 锁</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">analysis</span>(<span class="params">str_</span>):</span></span><br><span class="line">    get = json.load(str_)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> get.get(<span class="string">&quot;command&quot;</span>):</span><br><span class="line">        print(<span class="string">&quot;接收数据不包含指令,内容为&quot;</span>,str_)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    th = thread_template(thread_id_count, get.get(<span class="string">&quot;command&quot;</span>), get)</span><br><span class="line">    threads.append(th)</span><br><span class="line">    th.start()</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;hhh,&quot;</span>+str_</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">host = <span class="string">&quot;&quot;</span></span><br><span class="line">port = <span class="number">800</span></span><br><span class="line">address = (host, port)</span><br><span class="line">time_now = time.strftime(<span class="string">&quot;%Y-%m-%d %H:%S:%M&quot;</span>, time.localtime())</span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">s.bind(address)</span><br><span class="line">s.listen(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">threads = [] <span class="comment"># 进程们</span></span><br><span class="line">threadLock = threading.Lock() <span class="comment"># 锁</span></span><br><span class="line">thread_id_count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    print(<span class="string">&quot;Waiting for connections...&quot;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        client_connection, client_address = s.accept()</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        <span class="keyword">raise</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        traceback.print_exc()</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span> (<span class="string">&quot;Got connection from&quot;</span>, client_connection.getpeername())</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="comment"># client_connection.settimeout(5)</span></span><br><span class="line">            buf = client_connection.recv(<span class="number">1024</span>)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(buf) == <span class="number">0</span>: <span class="comment"># break,跳出while循环</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                client_connection.send(<span class="built_in">bytes</span>(analysis(buf.decode()), encoding=<span class="string">&quot;utf8&quot;</span>))  </span><br><span class="line">    <span class="keyword">except</span> (KeyboardInterrupt, SystemError):</span><br><span class="line">        <span class="keyword">raise</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        traceback.print_exc()</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    client_connection.close()</span><br><span class="line"><span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">    <span class="keyword">raise</span></span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    traceback.print_exc()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> socket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 国内镜像</title>
      <link href="/new/2021/02/04/Python%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F/"/>
      <url>/new/2021/02/04/Python%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="一次性使用"><a href="#一次性使用" class="headerlink" title="一次性使用"></a>一次性使用</h3><ul><li>pip install -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a>  numpy表示安装numpy库</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -i https://pypi.tuna.tsinghua.edu.cn/simple </span><br></pre></td></tr></table></figure><ul><li><p>其他的镜像源:<br>阿里云 <a href="http://mirrors.aliyun.com/pypi/simple/">http://mirrors.aliyun.com/pypi/simple/</a><br>中国科技大学 <a href="https://pypi.mirrors.ustc.edu.cn/simple/">https://pypi.mirrors.ustc.edu.cn/simple/</a><br>豆瓣(douban) <a href="http://pypi.douban.com/simple/">http://pypi.douban.com/simple/</a><br>清华大学 <a href="https://pypi.tuna.tsinghua.edu.cn/simple/">https://pypi.tuna.tsinghua.edu.cn/simple/</a><br>中国科学技术大学 <a href="http://pypi.mirrors.ustc.edu.cn/simple/">http://pypi.mirrors.ustc.edu.cn/simple/</a></p></li><li><p>库名查询:</p><p>[PyPi](<a href="https://pypi.org/">PyPI · The Python Package Index</a>)</p></li></ul><h3 id="长期使用"><a href="#长期使用" class="headerlink" title="长期使用"></a>长期使用</h3><p>Windows新建C:\Users\xx\pip\pip.ini文件,</p><p>Linux新建 ~/.pip/pip.conf</p><p>然后填入以下内容</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[global]</span></span><br><span class="line"><span class="attr">index-url</span> = https://pypi.tuna.tsinghua.edu.cn/simple</span><br><span class="line"><span class="attr">trusted-host</span> = pypi.tuna.tsinghua.edu.cn</span><br><span class="line"><span class="attr">disable-pip-version-check</span> = <span class="literal">true</span></span><br><span class="line"><span class="attr">timeout</span> = <span class="number">120</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> windows </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拍一拍文案</title>
      <link href="/new/2021/02/04/%E6%8B%8D%E4%B8%80%E6%8B%8D/"/>
      <url>/new/2021/02/04/%E6%8B%8D%E4%B8%80%E6%8B%8D/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="抄来的微信拍一拍后缀文案"><a href="#抄来的微信拍一拍后缀文案" class="headerlink" title="抄来的微信拍一拍后缀文案"></a>抄来的微信拍一拍后缀文案</h1><p><img src="v2-96944c20753a77154316ce02f3454bc1_b.jpg" alt="100句超火搞笑、微信拍一拍后缀文案！"></p><ol><li><p>拍了拍我的 砖头表示自己很怂</p></li><li><p> 拍了拍我的 衣服掉了一地灰</p></li><li><p> 拍了拍我的 枕头说过去点一起</p></li><li><p> 拍了拍我的 球弹弹弹走鱼尾纹</p></li><li><p> 拍了拍我的 窗户露出一张鬼脸</p></li><li><p> 拍了拍我的 狗子转头就是一口</p></li><li><p>拍了拍我的屁股，然后走人</p></li><li><p>拍了拍我的素颜表示磕碜至极</p></li><li><p>拍了拍我的钱包说养我一辈子</p></li><li><p>拍了拍我的儿子说大哥您好！</p></li><li><p>拍了拍我的米饭说再来十碗</p></li><li><p>拍了拍我的前任坟头并烧了香</p></li><li><p>拍了拍我的垃圾桶说我爱我家</p></li><li><p>拍了拍我的 小脑瓜然后变成猪</p></li><li><p>拍了拍我的 脑门，明明没烧啊</p></li><li><p>拍了拍我的 良心，啊，并没有</p></li><li><p>拍了拍我的 狗头并且踹了一脚</p></li><li><p>拍了拍我的 呆毛表示手感极佳</p></li><li><p>拍了拍我的 头顶却没摸到秀发</p></li><li><p>拍了拍我的 肩膀并喊了声爹</p></li><li><p>拍了拍我的 脑袋怀疑注水过度</p></li><li><p>拍了拍我的 脑瓜表示并不灵光</p></li><li><p>拍了拍我的 膝盖并跳起来打我</p></li><li><p>拍了拍我的 脚并被无情地踹飞</p></li><li><p>拍了拍我的 背，您这泥儿真多</p></li><li><p>拍了拍我的 对象，发现在做梦</p></li><li><p>拍了拍我的 钱包说养我一辈子</p></li><li><p>拍了拍我的方便面并碎了一地</p></li><li><p>拍了拍我的黄瓜并撒了把盐</p></li><li><p>拍了拍我的头像并喊了声爹</p></li><li><p>拍了拍我的狗还和狗抢吃的</p></li><li><p>拍了拍我的肩膀说爸辛苦了</p></li><li><p>拍了拍我的 床说睡吧要梦到我</p></li><li><p>拍了拍我的 床说猪啊还在睡</p></li><li><p>拍了拍我的 飞船表示也想上天</p></li><li><p>拍了拍我的 大奔（一切奢侈品）感到十分嫉妒</p></li><li><p>拍了拍我的 后座说送我回家</p></li><li><p>拍了拍我的钱包说真穷</p></li><li><p>拍了拍我的床让我少睡点</p></li><li><p>拍了拍我的西瓜，想挖一勺</p></li><li><p>拍了拍我的奶茶，想喝一口</p></li><li><p>拍了拍我的八块腹肌直流口水</p></li><li><p>拍了拍我的胸说“咋这大个”</p></li><li><p>拍了拍我的我的领导说，开了我</p></li><li><p>拍了拍我的自己的马屁</p></li><li><p>拍了拍我的小嘴说女人你在玩火</p></li><li><p>拍了拍我的脑袋说要快快长大</p></li><li><p>拍了拍我的脑袋说没事小家伙</p></li><li><p>拍了拍我的肚子决定请她吃饭</p></li><li><p>拍了拍我的头却听到噗通噗通</p></li><li><p>拍了拍我的小脑袋觉得很可爱</p></li><li><p>拍了拍我的肚子问：几个月了</p></li><li><p>拍了拍我的小脸并啵儿了一口</p></li><li><p>拍了拍我的头被一脚踹飞</p></li><li><p>拍了拍我的小屁股被揍了</p></li><li><p>拍了拍我的膝盖还要搭梯子</p></li><li><p>拍了拍我的脸蛋说美女在吗</p></li><li><p>拍了拍我的头说你是仙女吗</p></li><li><p>拍了拍我的胸发现她并没有</p></li><li><p>拍了拍我的的素颜照被吓哭</p></li><li><p>拍了拍我的前任遗照上的灰尘</p></li><li><p>拍了拍我的的世界第一帅证书</p></li><li><p>拍了拍我的的世界第一美证书</p></li><li><p>拍了拍我的马桶，留下了口水</p></li><li><p>拍了拍我的车,说打工不可能的</p></li><li><p>拍了拍我的小鹿说怎么还不撞</p></li><li><p>拍了拍我的钱包决定给她转账</p></li><li><p>拍了拍我的傻逼队友的脑瓜子</p></li><li><p>拍了拍我的桃树说要快点开花</p></li><li><p>拍了拍我的窗户露出一张鬼脸</p></li><li><p>拍了拍我的砖头表示自己很怂</p></li><li><p>拍了拍我的桌子，姐就是不服</p></li><li><p>拍了拍我的喇叭，前面的让开</p></li><li><p>拍了拍我的城堡大门却被赶走</p></li><li><p>拍了拍我的网易云，说生而为人</p></li><li><p>拍了拍我的兰博基尼让我载她</p></li><li><p>拍了拍我的胸说好大</p></li><li><p>拍了拍我的肩膀说爸你辛苦了</p></li><li><p>拍了拍我的头 并叫了声爸爸</p></li><li><p>拍了拍我的尊贵的脚指头</p></li><li><p>拍了拍我的男朋友（易烊千玺，王源，王俊凯，杨洋，李易峰等等）</p></li><li><p>拍了拍我的女朋友（赵丽颖，迪丽热巴，古力娜扎等等）</p></li><li><p>拍了拍我的宇宙飞船要我让座</p></li><li><p>拍了拍我的脑袋瓜说 真聪明</p></li><li><p>拍了拍我的充满智慧的大脑</p></li><li><p>拍了拍我的膝盖说 拍不到头</p></li><li><p>拍了拍我的鞋说 假的</p></li><li><p>拍了拍我的小脑瓜 然后变成猪</p></li><li><p>拍了拍我的 良心 啊 没有</p></li><li><p>拍了拍我的 圆润肚子 还可以吃</p></li><li><p>拍了拍我的肩膀，说你真的不胖</p></li><li><p>拍了拍我的手说：就这？</p></li><li><p>拍了拍我的 后背叫了声大哥</p></li><li><p>拍了拍我的 问你不会百度吗</p></li><li><p>拍了拍我的 头发说什么洗发水</p></li><li><p>拍了拍我的 瘪钱包哭出了声</p></li><li><p>拍了拍我的 饭碗给了一只鸡腿</p></li><li><p>拍了拍我的 仙人掌哈哈大笑</p></li><li><p>拍了拍我的 宠物叫了声祖宗</p></li><li><p>拍了拍我的 皮肤说吹弹可破</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows10路径过长 解决办法</title>
      <link href="/new/2021/02/04/%E8%B7%AF%E5%BE%84%E8%BF%87%E9%95%BF/"/>
      <url>/new/2021/02/04/%E8%B7%AF%E5%BE%84%E8%BF%87%E9%95%BF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>还在解决中,先填坑占位</p><img src="%E8%B7%AF%E5%BE%84%E8%BF%87%E9%95%BF/image-20210204210025986.png" alt="image-20210204210025986" style="zoom: 67%;" /><p>经查证,原有文件名字路径长度</p><p>C:\Users\m1576\Desktop\behavior-electron-vue-master\node_modules\pac-proxy-agent\node_modules\https-proxy-agent.github</p><p>这是由于全局utf8导致的</p>]]></content>
      
      
      
        <tags>
            
            <tag> windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World!</title>
      <link href="/new/2021/02/03/hello-world/"/>
      <url>/new/2021/02/03/hello-world/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>经典的问候(这里应该有一张图片,但是还无法显示,目前努力中)</p><img src="source/img/assets/image-20210204134821689.png" alt="image-20210204134821689" style="zoom:25%;" />]]></content>
      
      
      
        <tags>
            
            <tag> Hello world </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
